# 自己动手写docker 开发笔记

## 开发环境

- go version 1.21
- Goland 使用部署和rsync传输到Linux执行
- Goland设置=>Go=>构建标记os为linux
- 阿里云ecs、本地虚拟机 都是ubuntu22.04（其实一台完全没问题）
- 两台不要都安装docker！！！（在容器网络中会有坑）
- cgroup版本为2

## 基础技术

### Linux Namespace

Linux Namespace 是一种内核特性，用于提供一种进程隔离的机制，使得一组进程看起来像是在一个独立的环境中运行，而实际上它们共享同一个系统。不同的 Namespace 提供了不同的隔离层次，有助于实现进程、网络、文件系统等方面的隔离。以下是一些常见的 Linux Namespace 及其作用：

1. **PID Namespace (pid):** 允许一个进程及其子进程拥有自己独立的进程 ID 空间，使得它们在不同的 PID Namespace 中互不可见。

2. **Network Namespace (net):** 提供独立的网络栈，使得每个 Namespace 中的进程拥有独立的网络接口、IP 地址、路由表等网络资源。这对于实现网络隔离非常有用，比如容器化技术就广泛使用了 Network Namespace。

3. **Mount Namespace (mnt):** 允许进程拥有独立的文件系统挂载点层次结构。这使得不同 Namespace 中的进程可以拥有不同的文件系统视图，实现文件系统的隔离。

4. **UTS Namespace (uts):** 允许进程拥有独立的主机名和域名。

5. **IPC Namespace (ipc):** 提供独立的进程间通信资源，比如消息队列、信号量等。不同 IPC Namespace 中的进程无法直接通信。

6. **User Namespace (user):** 允许进程在不同的 Namespace 中具有不同的用户和组 ID 映射，实现用户身份的隔离。

这些 Namespace 可以单独或组合使用，从而实现多个层次的隔离，例如容器技术就是利用了多个 Namespace 来实现进程级别的隔离，使得容器内的进程在某些方面看起来像在一个独立的操作系统中运行一样。

系统调用参数

| Namespace类型     | 系统调用参数  | 内核版本 |
| ----------------- | ------------- | -------- |
| Mount Namespace   | CLONE_NEWNS   | 2.4.19   |
| UTS Namespace     | CLONE_NEWUTS  | 2.6.19   |
| IPC Namespace     | CLONE_NEWIPC  | 2.6.19   |
| PID Namespace     | CLONE_NEWPID  | 2.6.24   |
| Network Namespace | CLONE_NEWNET  | 2.6.29   |
| User Namespace    | CLONE_NEWUSER | 3.8      |

查看Linux内核版本的命令

```bash
uname -r
# cat /proc/version
```



Namespace 的API主要使用如下3个系统调用。

- clone()创建新进程。根据系统调用参数来判断哪些类型的Namespace被创建，而且它们的子进程也会被包含到这些Namespace
- unshare() 将进程移出某个Namespace。
- setns()将进程加入到Namespace中。

#### UTS Namespace

> `echo $$` 命令用于在 shell 中打印当前进程的进程 ID（PID）。这个命令在大多数常见的 Unix/Linux shell 中都是有效的。

```go
package main

import (
	"log"
	"os"
	"os/exec"
	"syscall"
)

func main() {
	cmd := exec.Command("sh")
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Cloneflags: syscall.CLONE_NEWUTS,
	}
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
}
```

在一个终端中执行

```sh
root@iZuf6j3esdg00724fgc2r5Z:~/mydocker/style/namespace/uts# go run main.go
# hostname
iZuf6j3esdg00724fgc2r5Z
# pstree -pl
sshd(70747)───bash(70804)───go(70827)─┬─main(70861)─┬─sh(70865)───pstree(70867)
# echo $$
70865
# readlink /proc/70861/ns/uts
uts:[4026531838]
# readlink /proc/70865/ns/uts        
uts:[4026532290]
# hostname -b bird
# hostname
bird
```

新的终端还是之前的hostname

```sh
root@iZuf6j3esdg00724fgc2r5Z:~# hostname
iZuf6j3esdg00724fgc2r5Z
```

#### IPC NameSpace

```go
package main

import (
	"log"
	"os"
	"os/exec"
	"syscall"
)

func main() {
	cmd := exec.Command("sh")
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Cloneflags: syscall.CLONE_NEWIPC | syscall.CLONE_NEWUTS,
	}
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
}

```

> `ipcs` 是一个 Linux/Unix 系统上的命令，用于显示进程间通信（IPC）资源的信息。IPC 是指进程之间进行通信和共享资源的机制，包括消息队列、信号量和共享内存等。
>
> 1. **看所有 IPC 资源：**
>
>    ```
>    ipcs
>    ```
>    
>   这会列出当前系统上所有的消息队列、信号量和共享内存的信息。
>    
>2. **查看特定类型的 IPC 资源：**
> 
>   ```
>    ipcs -q   # 查看消息队列信息
>    ipcs -s   # 查看信号量信息
>    ipcs -m   # 查看共享内存信息
>   ```

> `ipcmk` 命令是 Linux/Unix 系统上用于创建 IPC（进程间通信）资源的命令。它通常用于创建消息队列、信号量和共享内存等 IPC 资源。
>
> 具体来说，`ipcmk` 通常配合着 IPC 对象的描述文件（通常是一个文本文件），根据描述文件的内容创建相应的 IPC 资源。描述文件中包含了 IPC 对象的参数和属性。
>
> 1. **从描述文件创建 IPC 资源：**
>
>    ```
>    ipcmk -Q filename   # 从描述文件创建消息队列
>    ipcmk -S filename   # 从描述文件创建信号量
>    ipcmk -M filename   # 从描述文件创建共享内存
>    ```
>    
>   这里，`filename` 是包含 IPC 对象参数和属性的描述文件的名称。不同的选项对应不同类型的 IPC 资源。
>    
>2. **使用 `-q`、`-s`、`-m` 选项创建 IPC 资源：**
> 
>   ```
>    ipcmk -q key    # 创建消息队列
>    ipcmk -s key    # 创建信号量
>    ipcmk -m key    # 创建共享内存
>   ```
>    
> 这些选项直接指定 IPC 对象的关键字（key），而不需要描述文件。

启动一个终端

```bash
root@iZuf6j3esdg00724fgc2r5Z:~# ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    

root@iZuf6j3esdg00724fgc2r5Z:~# ipcmk -Q
Message queue id: 0
root@iZuf6j3esdg00724fgc2r5Z:~# ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xf20dda0d 0          root       644        0            0           

root@iZuf6j3esdg00724fgc2r5Z:~# 
```

启动另一个终端

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/mydocker/style# go run namespace/ipc/main.go
# ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    

# 
```

#### PID Namespace

```go
package main

import (
	"log"
	"os"
	"os/exec"
	"syscall"
)

func main() {
	cmd := exec.Command("sh")
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Cloneflags: syscall.CLONE_NEWPID | syscall.CLONE_NEWIPC | syscall.CLONE_NEWUTS,
	}
	cmd.Stdout = os.Stdout
	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
}

```

启动一个终端

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/mydocker/style# go run namespace/pid/main.go
# echo $$
1

```

启动另一个终端

```bash
root@iZuf6j3esdg00724fgc2r5Z:~# pstree -pl
...
sshd(69908)─┬─bash(70663)───go(70682)─┬─main(70722)─┬─sh(70726)
...
```

#### Mount Namespace

> Mount Namespace是Linux 第一个实现的Namespace 类型，因此，它的系统调用参数是NEWNS（New Namespace 的缩写）。当时人们貌似没有意识到，以后还会有很多类型的Namespace加入Linux大家庭。

> `mount` 命令用于将文件系统挂载到指定的目录，使得该目录成为文件系统的入口点。`mount` 命令的基本语法是：
>
> mount [选项] 设备文件 挂载点

```go
package main

import (
	"log"
	"os"
	"os/exec"
	"syscall"
)

func main() {
	cmd := exec.Command("sh")
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Cloneflags: syscall.CLONE_NEWNS | syscall.CLONE_NEWPID | syscall.CLONE_NEWIPC | syscall.CLONE_NEWUTS,
	}
	cmd.Stdout = os.Stdout
	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
}

```

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/mydocker/style# go run namespace/mount/main.go
# ls /proc
1    13     19220  234    25     26188  302    48317  53375  70682  71678  81  98          dma            key-users    mtrr          sysrq-trigger
10   14     19223  235    25126  26195  31     48677  53406  70722  71718  82  99          driver         keys         net           sysvipc
100  1407   19259  236    25181  26201  32     48680  582    70726  71873  83  acpi        dynamic_debug  kmsg         pagetypeinfo  thread-self
101  149    19287  237    254    26205  32442  48682  6      70747  71924  84  bootconfig  execdomains    kpagecgroup  partitions    timer_list
103  15     19335  238    25928  26208  33     48695  67647  70804  72096  85  buddyinfo   fb             kpagecount   pressure      tty
104  1577   2      23917  25988  26214  34     48696  67727  70985  72156  86  bus         filesystems    kpageflags   schedstat     uptime
105  16     20     23919  26     26228  4      48697  67955  70999  72207  87  cgroups     fs             loadavg      scsi          version
11   170    21     23920  26007  27     410    5      68032  71001  72314  88  cmdline     interrupts     locks        self          version_signature
117  18     22     23923  26020  27979  411    53318  69482  71080  72347  90  consoles    iomem          mdstat       slabinfo      vmallocinfo
12   19     224    23932  26023  29     413    53324  69908  71113  72351  92  cpuinfo     ioports        meminfo      softirqs      vmstat
120  19199  225    24     26024  3      415    53330  69965  71170  72352  93  crypto      irq            misc         stat          zoneinfo
121  19200  226    24029  26157  30     48274  53371  70079  71279  8      95  devices     kallsyms       modules      swaps
126  19213  231    241    26182  301    48306  53372  70663  71456  80     96  diskstats   kcore          mounts       sys
# mount -t proc proc /proc
# ls /proc
1           bus       crypto     dynamic_debug  interrupts  kcore        kpagecount  meminfo  net           scsi      swaps          timer_list         vmallocinfo
4           cgroups   devices    execdomains    iomem       key-users    kpageflags  misc     pagetypeinfo  self      sys            tty                vmstat
acpi        cmdline   diskstats  fb             ioports     keys         loadavg     modules  partitions    slabinfo  sysrq-trigger  uptime             zoneinfo
bootconfig  consoles  dma        filesystems    irq         kmsg         locks       mounts   pressure      softirqs  sysvipc        version
buddyinfo   cpuinfo   driver     fs             kallsyms    kpagecgroup  mdstat      mtrr     schedstat     stat      thread-self    version_signature
# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 14:22 pts/6    00:00:00 sh
root           6       1  0 14:29 pts/6    00:00:00 ps -ef
```

#### User Namespace

> `id` 命令用于显示当前用户的用户标识（UID）、组标识（GID）以及所属的附加组信息。它还可以显示用户和组的名称，而不仅仅是数字标识符。

```go
package main

import (
	"log"
	"os"
	"os/exec"
	"syscall"
)

func main() {
	cmd := exec.Command("sh")
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Cloneflags: syscall.CLONE_NEWUSER | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID | syscall.CLONE_NEWIPC | syscall.CLONE_NEWUTS,
	}
	cmd.Stdout = os.Stdout
	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
	os.Exit(-1)
}

```

```bash
root@iZuf6j3esdg00724fgc2r5Z:~# id
uid=0(root) gid=0(root) groups=0(root)
root@iZuf6j3esdg00724fgc2r5Z:~/mydocker/style# go run namespace/user/main.go
$ id
uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)
```

#### Network Namespace

```go
package main

import (
	"log"
	"os"
	"os/exec"
	"syscall"
)

func main() {
	cmd := exec.Command("sh")
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Cloneflags: syscall.CLONE_NEWNET | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID | syscall.CLONE_NEWIPC | syscall.CLONE_NEWUTS,
	}
	cmd.Stdout = os.Stdout
	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
	os.Exit(-1)
}

```

```bash
root@iZuf6j3esdg00724fgc2r5Z:~# ifconfig
Warning: cannot open /proc/net/dev (No such file or directory). Limited output.
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.28.106.22  netmask 255.255.240.0  broadcast 172.28.111.255
        ether 00:16:3e:24:3b:c4  txqueuelen 1000  (Ethernet)

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)

root@iZuf6j3esdg00724fgc2r5Z:~# cd mydocker/style
root@iZuf6j3esdg00724fgc2r5Z:~/mydocker/style# go run namespace/network/main.go
$ ifconfig
Warning: cannot open /proc/net/dev (No such file or directory). Limited output.
$ 
```

### Linux Cgroups

Linux Cgroups（Control Groups）提供了对一组进程及将来子进程的资源限制、控制和统计的能力，这些资源包括CPU、内存、存储、网络等。通过Cgroups，可以方便地限制某个进程的资源占用，并且可以实时地监控进程的监控和统计信息。

Linux Cgroups 由三个主要组件组成：

1. **Subsystem（控制器）:**
   
   - 控制器是 Cgroups 的资源管理模块，负责监控和限制特定资源的使用。常见的控制器包括：
     - **cpu：** 控制 CPU 资源的分配和使用。
     - **memory：** 管理内存资源，限制进程组的内存使用。
     - **blkio：** 控制块设备 I/O 资源，用于限制磁盘 I/O。
     - **net_cls 和 net_prio：** 用于网络资源控制。
   
   >  当前的内核支持哪些subsystem
   
   ```bash
   root@iZuf6j3esdg00724fgc2r5Z:~# apt install cgroup-tools
   root@iZuf6j3esdg00724fgc2r5Z:~# lssubsys -a
   cpuset
   cpu
   cpuacct
   blkio
   memory
   devices
   freezer
   net_cls
   perf_event
   net_prio
   hugetlb
   pids
   rdma
   misc
   ```
   
2. **Cgroup（控制组）:**
   
   - Cgroup 是资源控制组的实例，表示一组进程及其子进程。每个 Cgroup 都被分配给一个或多个控制器，它们负责管理这些进程的资源使用。你可以在 Cgroup 中设置资源限制和配置。
   
3. **Hierarchy（层次结构）:**
   - Cgroups 可以以层次结构的形式组织，形成一个树状结构。层次结构允许你以更精细的方式管理和分配资源。在一个层次结构中，你可以有多个 Cgroup，每个 Cgroup 都可以有自己的资源限制和配置。父级 Cgroup 的限制也会传递给其子级。

这三个组件共同工作，使得 Cgroups 能够实现对进程组的资源隔离和控制。在后端开发中，理解这些组件将有助于优化应用程序的性能，并确保有效地利用系统资源。

#### 创建Cgroups

Cgroups中的hierarchy是一种树状的组织结构，Kernel为了使对Cgroups的配置更直观，是通过一个虚拟的树状文件系统配置Cgroups的，通过层级的目录虚拟出cgroup树

```bash
root@iZuf6j3esdg00724fgc2r5Z:~# mkdir cgroup-test
root@iZuf6j3esdg00724fgc2r5Z:~# mount -t cgroup -o none,name=cgroup-test cgroup-test ./cgroup-test
root@iZuf6j3esdg00724fgc2r5Z:~#  ls ./cgroup-test 
cgroup.clone_children  cgroup.procs  cgroup.sane_behavior  notify_on_release  release_agent  tasks
```

> 挂载 Cgroup 的命令是：
>
> ```
> mount -t cgroup -o none,name=cgroup-test cgroup-test ./cgroup-test
> ```
>
> 在这个命令中：
>
> - `-t cgroup` 指定文件系统类型为 cgroup。
> - `-o none,name=cgroup-test` 指定挂载选项，其中 `name=cgroup-test` 表示为 Cgroup 设置一个名称。
> - `cgroup-test` 是你指定的 Cgroup 的名称。
> - `./cgroup-test` 是挂载点，即挂载到文件系统的目标位置。

1. **`cgroup.clone_children`:**
   - 该文件用于控制 Cgroup 是否应该在创建新进程时克隆其子系统的配置。如果文件内容为1，则表示应该克隆子系统的配置。如果为0，则表示不应该。
2. **`cgroup.procs`:**
   - 是树中当前节点cgroup中的进程组ID，现在的位置是在根节点，这个文件中会有现在系统中所有进程组的ID
3. **`cgroup.sane_behavior`:**
   - 该文件用于启用或禁用 Cgroup 的某些行为。如果文件内容为1，则表示启用“合理行为”模式。如果为0，则表示禁用。
4. **`notify_on_release`:**
   - 当 Cgroup 被释放（destroyed）时，该文件中指定的进程将收到通知。这可以用于执行一些清理操作。
5. **`release_agent`:**
   - 当 Cgroup 被释放时，该文件指定的程序将被执行。这通常用于自动化一些释放后的操作。
6. **`tasks`:**
   - 标识该cgroup下面的进程ID，如果把一个进程ID写到tasks文件中，便会将相应的进程加入到这个cgroup中。

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/cgroup-test# mkdir cgroup-1
root@iZuf6j3esdg00724fgc2r5Z:~/cgroup-test# mkdir cgroup-2
root@iZuf6j3esdg00724fgc2r5Z:~/cgroup-test# tree
.
├── cgroup-1
│   ├── cgroup.clone_children
│   ├── cgroup.procs
│   ├── notify_on_release
│   └── tasks
├── cgroup-2
│   ├── cgroup.clone_children
│   ├── cgroup.procs
│   ├── notify_on_release
│   └── tasks
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
└── tasks
```

在一个cgroup的目录下创建文件夹时，Kernel会把文件夹标记为这个cgroup的子cgroup，它们会继承父cgroup的属性。

#### 移动进程

一个进程在一个Cgroups的hierarchy中，只能在一个cgroup节点上存在，系统的所有进程都会默认在根节点上存在，可以将进程移动到其他cgroup节点，只需要将进程ID写到移动到的cgroup节点的tasks文件中即可。

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/cgroup-test/cgroup-1# echo $$
1450
root@iZuf6j3esdg00724fgc2r5Z:~/cgroup-test/cgroup-1# echo $$ >> tasks
root@iZuf6j3esdg00724fgc2r5Z:~/cgroup-test/cgroup-1# cat tasks
1450
1996
root@iZuf6j3esdg00724fgc2r5Z:~/cgroup-test/cgroup-1# cat /proc/1450/cgroup
1:name=cgroup-test:/cgroup-1
0::/user.slice/user-0.slice/session-3.scope
```

可以看到，当前的7475进程已经被加到cgroup-test:/cgroup-1中了

#### 限制资源

```bash
 # 测试占用200m内存
 stress --vm-bytes 200m --vm-keep -m 1
	PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                       
   2817 root      20   0  208512 204924    268 R 100.0  11.7   0:12.57 stress
```

```bash
# 给cgroup-1限制内存100m

```

。。。

#### 删除子cgroup

将子group的进程全部移到父cgroup，然后使用`rmdir cgroupname`进行删除

如果是自己挂载的，还需要使用umount取消挂载

#### cgroup2与cgroup1不同

`cgroup2`（Control Groups v2）和`cgroup1`（Control Groups v1）都是Linux内核中用于资源控制和隔离的机制，但它们在实现和功能上存在一些显著的差异。以下是它们之间的一些主要区别：

1. **层次结构**:
   - **cgroup1**: 使用了类似文件系统的层次结构，其中每个控制组都有一个在文件系统中的路径。cgroup1的层次结构相对较为复杂。
   - **cgroup2**: 采用了简化的层次结构，通过单一的`/sys/fs/cgroup/unified`路径提供对所有控制组的访问。

2. **控制器**:
   - **cgroup1**: 每个控制器（如cpu、memory、blkio等）都有独立的层次结构。一个进程可以属于多个控制器的不同层次结构。
   - **cgroup2**: 所有控制器都合并到一个单一的层次结构中，以简化管理。一个进程只能属于一个cgroup2。

3. **性能和扩展性**:
   - **cgroup1**: 在大规模系统中，由于层次结构的复杂性，可能会导致性能问题。
   - **cgroup2**: 设计目标之一是提高性能和扩展性，以适应更大规模的系统。

4. **配置和语法**:
   - **cgroup1**: 使用类似于挂载点和配置文件的方式，配置较为繁琐。
   - **cgroup2**: 引入了新的配置文件和语法，以简化配置和管理。

5. **资源控制的粒度**:
   - **cgroup1**: 控制资源的粒度相对较大，难以实现对任务和子任务的细粒度控制。
   - **cgroup2**: 具有更细粒度的资源控制，支持对单个任务的更精确限制。

6. **事件通知**:
   - **cgroup1**: 提供了限制、释放、超限等事件通知。
   - **cgroup2**: 引入了更灵活的事件通知机制，支持更多类型的事件，提供了更好的可扩展性。

在实践中，`cgroup2`被认为是`cgroup1`的改进版本，具有更好的性能和可用性。然而，由于不同版本的内核和特定的使用案例，选择使用哪个版本可能取决于具体的需求和环境。



在`cgroup2`中，后缀为 `.scope` 或 `.service` 的 cgroup 通常用于不同的目的，并且这样的命名约定是由系统使用者和管理者遵循的。

1. **`.scope`**：
   - 通常用于管理和隔离一组相关的任务（tasks）或进程。这种 cgroup 可以看作是一个任务组，它可以包含多个相关联的进程。这样的 cgroup 通常在系统管理中用于组织任务并提供一定程度的隔离。
   - 举例来说，当你启动一个新的 systemd 范围（scope）时，会创建一个以 `.scope` 结尾的 cgroup，用于隔离和管理相关的系统任务。

2. **`.service`**：
   - 通常用于与 systemd 服务相关的 cgroup。这样的 cgroup 可以包含属于同一服务的多个进程，以便进行资源控制和隔离。
   - 举例来说，当你启动一个 systemd 服务时，会创建一个以 `.service` 结尾的 cgroup，用于将服务的相关进程组织在一起。

这样的命名约定有助于更好地组织和理解 cgroups 的用途。通过这种方式，你可以轻松识别特定 cgroup 的功能，并理解其中包含的任务或服务的关联性。

总的来说，这种命名约定提供了一种直观的方式来了解 `cgroup2` 层次结构中各个 cgroup 的用途和关联。

#### docker是如何使用Cgroup

我的docker版本24.05，ubuntu版本22.04，Cgroup版本v2

对于 cgroup v2，Docker 在启动容器时创建一个独立的 cgroup，该 cgroup 位于 `/sys/fs/cgroup/system.slice` 目录下，具体路径可能包括 Docker 生成的唯一标识符。这个目录包含有关 Docker 容器的各个 cgroup 子系统的配置信息。

你可以通过查看该目录下的文件来获取与容器相关的 cgroup 配置。以下是一个示例命令，用于查看容器的 cgroup 配置信息：

```bash
ls /sys/fs/cgroup/system.slice/docker-<container_id>.scope/
```

请将 `<container_id>` 替换为你要查看的容器的实际 ID。

这个目录中的文件和子目录包含了容器在各个 cgroup 子系统中的配置信息。你可以根据需要查看相应的文件，以获取有关容器资源限制和配置的更多详细信息。

请注意，具体的路径可能因 Docker 版本和系统配置而有所不同。确保你使用的是支持 cgroup v2 的 Docker 版本，并参考 Docker 的官方文档以获取更详细和最新的信息。

例如：

```bash
root@iZuf6j3esdg00724fgc2r5Z:~# docker run -itd -m 128m ubuntu
bc0532cfc2182df354471382345c892404749733d7a4505154c7913390dfd7f5
root@iZuf6j3esdg00724fgc2r5Z:~# ls /sys/fs/cgroup/system.slice/docker-bc0532cfc2182df354471382345c892404749733d7a4505154c7913390dfd7f5.scope
cgroup.controllers      cpu.idle               cpu.uclamp.min            hugetlb.2MB.events.local  memory.events.local  memory.swap.high
cgroup.events           cpu.max                cpu.weight                hugetlb.2MB.max           memory.high          memory.swap.max
cgroup.freeze           cpu.max.burst          cpu.weight.nice           hugetlb.2MB.rsvd.current  memory.low           misc.current
cgroup.kill             cpu.pressure           hugetlb.1GB.current       hugetlb.2MB.rsvd.max      memory.max           misc.max
cgroup.max.depth        cpuset.cpus            hugetlb.1GB.events        io.max                    memory.min           pids.current
cgroup.max.descendants  cpuset.cpus.effective  hugetlb.1GB.events.local  io.pressure               memory.numa_stat     pids.events
cgroup.procs            cpuset.cpus.partition  hugetlb.1GB.max           io.prio.class             memory.oom.group     pids.max
cgroup.stat             cpuset.mems            hugetlb.1GB.rsvd.current  io.stat                   memory.pressure      rdma.current
cgroup.subtree_control  cpuset.mems.effective  hugetlb.1GB.rsvd.max      io.weight                 memory.stat          rdma.max
cgroup.threads          cpu.stat               hugetlb.2MB.current       memory.current            memory.swap.current
cgroup.type             cpu.uclamp.max         hugetlb.2MB.events        memory.events             memory.swap.events
root@iZuf6j3esdg00724fgc2r5Z:~# cat /sys/fs/cgroup/system.slice/docker-bc0532cfc2182df354471382345c892404749733d7a4505154c7913390dfd7f5.scope/memory.max
134217728 # 为128m
root@iZuf6j3esdg00724fgc2r5Z:~# 
```

#### 使用go语言实现cgroup限制资源

注意事项

1. /proc/self/exe`/proc/self/exe` 是一个符号链接，指向执行当前进程的可执行文件。在Linux系统中，`/proc/self` 是一个指向当前进程的虚拟文件系统目录，而 `exe` 是一个符号链接，链接到当前进程的可执行文件。

   因此，通过访问 `/proc/self/exe`，你可以获得当前正在执行的程序的路径。这对于需要获取自身可执行文件路径的程序是有用的。实际上，`/proc/self/exe` 实际上是一个指向 `/proc/<pid>/exe` 的符号链接，其中 `<pid>` 是当前进程的进程ID。所以，`/proc/self/exe` 实际上就是指向自己的可执行文件路径。

2. cgroup限制要在子进程创建之前设置好，书中程序有一点错误，这里修正好
3. stress内存不足会执行失败，而不是书中说的实际内存为原来的一半。将200m改成50m则成功。
4. 这里使用的是cgroup2，创建和配置有所不同

```go
package main

import (
	"fmt"
	"os"
	"os/exec"
	"path"
	"strconv"
	"syscall"
)

const cgroupSystemSlice = "/sys/fs/cgroup/system.slice"

func main() {
	if os.Args[0] == "/proc/self/exe" {
		fmt.Println("debug", "os.Args[0] = \"/proc/self/exe\"")
		// 容器进程
		fmt.Printf("current pid %d\n", syscall.Getpid())
		cmd := exec.Command("sh", "-c", "stress --vm-bytes 200m --vm-keep -m 1")
		cmd.Stdin = os.Stdin
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			fmt.Println("ERROR", err)
			os.Exit(1)
		}
	}
	mainPid := strconv.Itoa(syscall.Getpid())
	cgroupName := "stress" + mainPid + ".scope"
	// 创建cgroup
	_ = os.Mkdir(path.Join(cgroupSystemSlice, cgroupName), 0755)
	// 将容器进程加入到这个cgroup中
	_ = os.WriteFile(path.Join(cgroupSystemSlice, cgroupName, "cgroup.procs"), []byte(mainPid), 0644)
	// 限制进程内存100m
	_ = os.WriteFile(path.Join(cgroupSystemSlice, cgroupName, "memory.max"), []byte(strconv.Itoa(100*1024*1024)), 0644)
	fmt.Println("debug", cgroupName, "completed")
	cmd := exec.Command("/proc/self/exe")
	cmd.SysProcAttr = &syscall.SysProcAttr{
		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,
	}
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Start(); err != nil {
		fmt.Println("ERROR", err)
		os.Exit(1)
	}
	fmt.Println("debug", "child", cmd.Process.Pid, "start...")
	cmd.Process.Wait()
	fmt.Println("debug", "cmd.Process.Wait","finished")
}
```

```bash
pstree -lp
...
├─sshd(929)─┬─sshd(2517)───bash(2594)
           │           ├─sshd(2697)─┬─bash(2752)───pstree(11009)
           │           │            ├─bash(8920)───go(10956)─┬─main(10995)─┬─exe(10999)─┬─sh(11004)───stress(11005)───stress(11006)
...

# cgroupName为stress10995.scope
# cgroup.procs会包含10995 10999 11004 11005 11006
```

### Union File System

Union File System（联合文件系统），它允许将多个文件系统合并为一个单一的视图。这种合并是以层次结构的方式进行的，使得多个文件系统的内容看起来像是一个整体。常见的联合文件系统包括AUFS、OverlayFS和Overlay2。

写时复制（Copy-On-Write，简称COW）允许多个文件系统层次共享相同的数据，但只有在需要修改数据时才进行实际的复制。在容器技术中，写时复制对于快速创建和销毁容器实例以及有效地使用存储资源都起到了关键作用。不同的联合文件系统实现可能采用不同的写时复制策略，但基本原理是相似的。

理解原理和docker是如何使用的

https://mp.weixin.qq.com/s?__biz=Mzk0NzE5OTQyOQ==&mid=2247484175&idx=1&sn=4c7c0105cdac469842774b0bb1495e2c&chksm=c37bcfa5f40c46b3a705412f832af86e09823a7bb6083b8c63b3e734a6ec9c8bce3f68d644c4#rd

本次没有代码demo

#### overlay

OverlayFS（Overlay文件系统）是Linux内核的一个联合文件系统，它允许将两个文件系统叠加在一起，提供一个单一的、统一的文件系统视图。与Overlay2一样，OverlayFS可以被单独使用，而不仅仅局限于Docker。

你可以使用`mount`命令手动挂载OverlayFS文件系统，以便直接访问其内容或进行特定的操作。这需要一些了解OverlayFS的文件系统结构和挂载参数。

下面是一个简单的例子，演示如何手动挂载OverlayFS文件系统：

```bash
sudo mount -t overlay overlay -o lowerdir=/lower/directory,upperdir=/upper/directory,workdir=/work/directory /mnt/overlayfs
```

其中：
- `lowerdir`: 指定底层（基础）文件系统的目录。
- `upperdir`: 指定OverlayFS的上层（修改层）目录。
- `workdir`: 指定OverlayFS的工作目录。

`/mnt/overlayfs` 是你选择的挂载点，确保该目录已经存在。

请注意，直接操作OverlayFS文件系统可能会对系统产生影响，因此在进行此类操作之前，请确保你理解OverlayFS的工作原理，并小心谨慎地进行。

虽然OverlayFS可以独立于Docker使用，但它在容器和分布式存储方案中得到广泛应用，因为它提供了轻量、高性能的文件系统叠加方案。

## 构造容器

### Linux /proc

`/proc` 文件系统是 Linux 操作系统中的一个虚拟文件系统，用于提供对内核和系统运行时信息的访问。这个文件系统不包含实际的文件，而是包含内核和系统状态的伪文件，允许用户和进程通过读取或写入这些文件来与内核进行交互。以下是一些 `/proc` 文件系统的关键特点和用途：

1. **进程信息：** `/proc` 提供了有关系统中运行进程的信息。每个进程都在 `/proc` 中有一个以进程 ID 命名的目录，其中包含有关该进程的信息，如命令行参数、环境变量、打开的文件和子进程等。

   示例：`/proc/1234/`

2. **系统信息：** `/proc` 包含一些文件，提供了有关系统硬件、内存、CPU、内核版本等的信息。例如，`/proc/cpuinfo` 提供了有关 CPU 的详细信息，而 `/proc/meminfo` 提供了有关内存使用情况的信息。

   示例：`/proc/cpuinfo`, `/proc/meminfo`

3. **设备信息：** `/proc` 中有一些文件提供了关于系统设备的信息。例如，`/proc/devices` 列出了已加载的字符设备和块设备。

   示例：`/proc/devices`

4. **网络信息：** `/proc/net` 目录包含有关网络协议和连接的信息。例如，`/proc/net/tcp` 和 `/proc/net/udp` 提供了有关当前打开的 TCP 和 UDP 连接的信息。

   示例：`/proc/net/tcp`, `/proc/net/udp`

5. **内核参数：** `/proc/sys` 包含了一系列的文件，可以用于读取和设置内核参数。这些参数允许用户动态地调整系统的行为，如文件描述符限制、网络参数等。

   示例：`/proc/sys/net/ipv4/tcp_keepalive_time`

总体而言，`/proc` 文件系统为系统管理员、开发人员和调试人员提供了一种方便的方式来获取系统状态和配置信息，帮助诊断和调优系统性能。在编程和脚本中，可以利用这些文件来获取有关系统和进程的动态信息。

下面介绍几个进程信息比较重要的部分。

| 进程              | 介绍                                 |
| ----------------- | ------------------------------------ |
| /proc/N           | PID为N的进程信息                     |
| /proc/N/cmdline   | 进程启动命令                         |
| /proc/N/cwd       | 链接到进程当前工作目录               |
| /proc/N/environ   | 进程环境变量列表                     |
| /proc/N/exe       | 链接到进程的执行命令文件             |
| /proc/N/fd        | 包含进程相关的所有文件描述符         |
| /proc/N/maps      | 与进程相关的内存映射信息             |
| /proc/N/mem       | 指代进程持有的内存，不可读           |
| /proc/N/root      | 链接到进程的根目录                   |
| /proc/N/stat      | 进程的状态                           |
| /proc/N/statm     | 进程使用的内存状态                   |
| /proc/N/status    | 进程状态信息，比stat/statm更具可读性 |
| /proc/N/mountinfo | 找出与当前进程相关的mount信息        |
| /proc/self/       | 链接到当前正在运行的进程             |



### logrus

```bash
go get github.com/sirupsen/logrus
```

`Logrus` 是一个用 Go 语言编写的开源日志库。它提供了结构化的日志记录，并支持日志级别、钩子（hook）、格式化输出等功能。`Logrus` 的设计目标是简单易用，并能够满足各种日志记录需求。

以下是 `Logrus` 的一些特点和用法：

1. **日志级别：** `Logrus` 支持不同的日志级别，如调试（Debug）、信息（Info）、警告（Warning）、错误（Error）等，可以根据需求设置不同的级别。

2. **结构化日志：** 支持结构化日志记录，可以方便地记录键值对形式的信息。

3. **日志格式化：** 可以根据需要选择不同的日志输出格式，包括 JSON、文本等。

4. **Hook 支持：** 提供了钩子机制，可以通过钩子扩展日志记录的行为，比如将日志发送到远程服务器、存储到数据库等。

5. **字段添加：** 可以为日志记录添加额外的字段信息，以便更全面地描述日志事件。

以下是一个简单的使用示例，展示了 `Logrus` 的基本用法：

```go
package main

import (
	"github.com/sirupsen/logrus"
)

func main() {
	// 创建一个新的 Logger 实例
	logger := logrus.New()

	// 设置日志级别
	logger.SetLevel(logrus.DebugLevel)

	// 记录日志事件
	logger.WithFields(logrus.Fields{
		"animal": "walrus",
		"size":   10,
	}).Info("A group of walrus emerges from the ocean")

	// 记录错误日志
	logger.WithError(fmt.Errorf("This is an error")).Error("Something went wrong")
}
```

在上面的例子中，我们创建了一个 `Logrus` 的 Logger 实例，设置了日志级别为调试级别（DebugLevel），然后记录了两条日志事件，一条是信息日志，一条是错误日志。这只是一个简单的示例，你可以根据实际需求进行更复杂的日志记录和处理。

### cli

```bash
go get github.com/urfave/cli
```

`github.com/urfave/cli` 是 Go 语言中一个用于构建命令行应用的库，它提供了一组简单而强大的工具，使得命令行应用程序的开发变得更加容易。这库的官方简称是 "cli"。

该库的功能包括：

1. **命令和子命令的定义：** 允许你定义命令行应用程序及其子命令，使应用程序可以以层次结构的方式组织命令。

2. **参数解析：** 支持解析命令行参数和标志，以及提供了对参数的验证和提示的功能。

3. **帮助文档生成：** 自动生成用户友好的帮助文档，这在构建命令行工具时非常有用。

4. **自定义命令执行：** 提供了灵活的方式来定义每个命令的执行逻辑。

以下是一个简单的例子，展示了如何使用 `github.com/urfave/cli` 创建一个简单的命令行应用：

```go
package main

import (
	"fmt"
	"github.com/urfave/cli"
	"os"
)

func main() {
	// 创建一个新的命令行应用
	app := cli.NewApp()

	// 定义应用的基本信息
	app.Name = "MyCLI"
	app.Usage = "A simple command-line application"
	app.Version = "1.0.0"

	// 定义一个命令
	app.Commands = []cli.Command{
		{
			Name:    "greet",
			Aliases: []string{"g"},
			Usage:   "Greet the user",
			Action: func(c *cli.Context) error {
				fmt.Println("Hello, " + c.Args().First())
				return nil
			},
		},
	}

	// 运行应用
	err := app.Run(os.Args)
	if err != nil {
		fmt.Println(err)
	}
}
```

在上述例子中，我们创建了一个基本的命令行应用，定义了一个名为 "greet" 的子命令，该子命令接受一个参数并输出问候语。这只是 `github.com/urfave/cli` 的基本用法，你可以根据实际需求扩展和定制你的命令行应用。

### mount命令介绍

当使用Linux系统时，`mount`命令用于挂载文件系统到指定的目录，使文件系统中的内容在指定的目录可见。以下是`mount`命令的基本用法：

```bash
mount -t <filesystem_type> -o <mount_options> <source> <target>
```

- `<filesystem_type>`: 指定要挂载的文件系统类型，例如 ext4、ntfs、aufs 等。
- `<mount_options>`: 指定挂载选项，可以是多个以逗号分隔的选项，如读写权限、执行权限等。
- `<source>`: 指定要挂载的源设备或文件，可以是设备文件路径（如 /dev/sda1）或文件系统镜像路径。
- `<target>`: 指定挂载点，即文件系统将被挂载到该目录下。

以下是一些常见的例子：

1. 挂载一个分区到指定目录：
    ```bash
    mount /dev/sda1 /mnt/mydisk
    ```

2. 挂载一个ISO镜像文件：
    ```bash
    mount -o loop path/to/my.iso /mnt/cdrom
    ```

3. 挂载一个NFS共享：
    ```bash
    mount -t nfs server:/path/to/share /mnt/nfs
    ```

4. 挂载一个CIFS（Samba）共享：
    ```bash
    mount -t cifs -o username=myuser,password=mypassword //server/share /mnt/smb
    ```

5. 挂载一个aufs文件系统：
    ```bash
    mount -t aufs -o dirs=/mnt/lower:/mnt/upper none /mnt/aufs
    ```

请注意，为了卸载挂载点，可以使用 `umount` 命令，例如：

```bash
umount /mnt/mydisk
```

这些是基本的用法，具体的选项和参数可能会因文件系统类型或其他因素而有所不同。使用 `man mount` 命令可以查看`mount`命令的手册页，获取更详细的信息。

### cmd/syscall区别

在Go语言中，`cmd` 和 `syscall` 包都与系统级编程有关，但它们有不同的用途和重点。

1. **cmd 包：**
   - `cmd` 包通常用于执行外部命令或程序。它提供了 `Run` 函数，可以启动外部进程，并执行指定的命令。
   - 这对于在Go程序中执行外部命令（例如 shell 命令、其他可执行文件）非常有用。`cmd` 包使得与外部进程的交互变得相对容易。

   示例：
   ```go
   package main
   
   import (
       "fmt"
       "os/exec"
   )
   
   func main() {
       cmd := exec.Command("ls", "-l")
       output, err := cmd.CombinedOutput()
       if err != nil {
           fmt.Println("Error:", err)
           return
       }
       fmt.Println(string(output))
   }
   ```

2. **syscall 包：**
   - `syscall` 包提供了对底层系统调用的访问。它允许在Go程序中直接调用操作系统提供的系统调用，绕过标准库的封装。
   - 这对于需要更底层的系统编程、与系统资源直接交互的情况非常有用。通常用于一些特殊需求，如操作文件描述符、创建线程等。

   示例：
   ```go
   package main
   
   import (
       "fmt"
       "syscall"
   )
   
   func main() {
       // 使用 syscall 调用底层系统调用，这里以创建一个文件为例
       fd, err := syscall.Creat("example.txt", 0644)
       if err != nil {
           fmt.Println("Error:", err)
           return
       }
       fmt.Println("File descriptor:", fd)
   }
   ```

总体而言，`cmd` 包更适用于与外部命令和进程进行交互，而 `syscall` 包更适用于直接调用系统底层的系统调用。选择使用哪一个取决于你的具体需求和使用场景。



### go syscall.Mount

`syscall.Mount` 是 Go 语言中的一个系统调用，用于挂载文件系统。这个函数允许你在运行时将一个文件系统挂载到指定的目录上。它的作用是在指定的目录上建立一个与指定文件系统关联的挂载点，使得该目录成为文件系统的入口点。

以下是 `syscall.Mount` 的基本用法：

```go
package main

import (
	"syscall"
)

func main() {
	source := "source_device"  // 源设备
	target := "target_directory" // 目标目录
	fstype := "filesystem_type"  // 文件系统类型，例如 "ext4", "nfs", 等
	flags := uintptr(0)          // 挂载选项，可以是一些标志的组合
	data := "mount_options"      // 挂载选项，例如 "rw", "noexec", 等

	err := syscall.Mount(source, target, fstype, flags, data)
	if err != nil {
		panic(err)
	}

	// 在这里执行挂载后的操作

	err = syscall.Unmount(target, 0) // 卸载文件系统，需要在不再需要挂载的时候执行
	if err != nil {
		panic(err)
	}
}
```

注意，使用 `syscall.Mount` 需要在程序中拥有足够的权限，通常需要在 root 或具有挂载权限的用户下运行。此外，挂载后，必须在不再需要挂载的时候调用 `syscall.Unmount` 来卸载文件系统。

```bash
root@iZuf6j3esdg00724fgc2r5Z:~# mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=836300k,nr_inodes=209075,mode=755,inode64)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,nodev,noexec,relatime,size=174872k,mode=755,inode64)
/dev/vda3 on / type ext4 (rw,relatime)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,inode64)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k,inode64)
cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=29,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=17940)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
mqueue on /dev/mqueue type mqueue (rw,nosuid,nodev,noexec,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,nosuid,nodev,noexec,relatime)
tracefs on /sys/kernel/tracing type tracefs (rw,nosuid,nodev,noexec,relatime)
fusectl on /sys/fs/fuse/connections type fusectl (rw,nosuid,nodev,noexec,relatime)
configfs on /sys/kernel/config type configfs (rw,nosuid,nodev,noexec,relatime)
none on /run/credentials/systemd-sysusers.service type ramfs (ro,nosuid,nodev,noexec,relatime,mode=700)
tmpfs on /run/qemu type tmpfs (rw,nosuid,nodev,relatime,mode=755,inode64)
/var/lib/snapd/snaps/core20_2105.snap on /snap/core20/2105 type squashfs (ro,nodev,relatime,errors=continue,x-gdu.hide)
/var/lib/snapd/snaps/snapd_20671.snap on /snap/snapd/20671 type squashfs (ro,nodev,relatime,errors=continue,x-gdu.hide)
/dev/vda2 on /boot/efi type vfat (rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,nosuid,nodev,noexec,relatime)
tracefs on /sys/kernel/debug/tracing type tracefs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /run/snapd/ns type tmpfs (rw,nosuid,nodev,noexec,relatime,size=174872k,mode=755,inode64)
nsfs on /run/snapd/ns/lxd.mnt type nsfs (rw)
tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,size=174868k,nr_inodes=43717,mode=700,inode64)
portal on /run/user/0/doc type fuse.portal (rw,nosuid,nodev,relatime,user_id=0,group_id=0)
overlay on /var/lib/docker/overlay2/9446001156fdf2955336ed827717548caef4165688615d9a02e3c2f4d00c2954/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/7F5YQ4G2GBFFC27SPVZUPZQRJE:/var/lib/docker/overlay2/l/AO4T6C5OBUH6QL2LOJHJUDOLUQ,upperdir=/var/lib/docker/overlay2/9446001156fdf2955336ed827717548caef4165688615d9a02e3c2f4d00c2954/diff,workdir=/var/lib/docker/overlay2/9446001156fdf2955336ed827717548caef4165688615d9a02e3c2f4d00c2954/work)
nsfs on /run/docker/netns/9a82d120e2a2 type nsfs (rw)
overlay on /var/lib/docker/overlay2/903fd0873ab79448d0c840d5303e4c09c96a64290dd028892f50fe4455ec7344/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/QIPL5DIRADONCFMFGDMBVJYQOD:/var/lib/docker/overlay2/l/RLSMTCEBYEU6JKKP5VP27IHBED,upperdir=/var/lib/docker/overlay2/903fd0873ab79448d0c840d5303e4c09c96a64290dd028892f50fe4455ec7344/diff,workdir=/var/lib/docker/overlay2/903fd0873ab79448d0c840d5303e4c09c96a64290dd028892f50fe4455ec7344/work)
nsfs on /run/docker/netns/708947969d46 type nsfs (rw)
/var/lib/snapd/snaps/lxd_26881.snap on /snap/lxd/26881 type squashfs (ro,nodev,relatime,errors=continue,x-gdu.hide)
/var/lib/snapd/snaps/lxd_27037.snap on /snap/lxd/27037 type squashfs (ro,nodev,relatime,errors=continue,x-gdu.hide)
/var/lib/snapd/snaps/core20_2182.snap on /snap/core20/2182 type squashfs (ro,nodev,relatime,errors=continue,x-gdu.hide)
```



### go syscall.Exec

在 Go 语言中，`syscall.Exec` 是一个用于替换当前进程的系统调用函数。它通常与 `os/exec` 包一起使用，用于启动外部程序并替换当前的 Go 进程。`syscall.Exec` 的签名如下：

```go
func Exec(argv0 string, argv []string, envv []string) error
```

其中：
- `argv0` 是新程序的名称，它会被设置为新进程的 `argv[0]`。
- `argv` 是新程序的命令行参数切片，包括命令本身在内。
- `envv` 是新程序的环境变量切片。

当调用 `syscall.Exec` 时，它会取代当前的进程，加载指定的程序，并用指定的参数和环境变量来执行该程序。如果调用成功，当前的 Go 进程将被替换，而不是启动一个新的子进程。这使得在当前进程中启动其他程序变得可能，而无需创建新的进程。

这通常用于实现类似于 shell 中的 `exec` 命令的行为，即替换当前的进程，而不是在新的子进程中执行命令。这对于需要在当前进程中运行其他程序并且不需要保留当前进程的状态时非常有用。

以下是一个简单的示例，演示了如何使用 `syscall.Exec` 启动另一个程序：

```go
package main

import (
	"os"
	"syscall"
)

func main() {
	// 替换当前进程，执行 /bin/ls 命令
	err := syscall.Exec("/bin/ls", []string{"ls", "-l"}, os.Environ())
	if err != nil {
		panic(err)
	}
}
```

在这个例子中，调用 `syscall.Exec` 将当前进程替换为 `/bin/ls`，并传递了参数 `ls -l`。如果执行成功，当前进程将变成 `/bin/ls`，并显示当前目录的文件列表。

### 构造run版本容器

https://github.com/lin-coco/mydocker/tree/v0.1

**编译运行**

```bash
go build
./mydocker run -it /bin/sh
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -it /bin/sh
{"level":"info","msg":"init come on","time":"2024-01-19T16:32:01+08:00"}
{"level":"info","msg":"command /bin/sh","time":"2024-01-19T16:32:01+08:00"}
{"level":"info","msg":"command /bin/sh","time":"2024-01-19T16:32:01+08:00"}
$ 

```

```bash
pstree -lp
....
           ├─sshd(929)───sshd(14537)─┬─bash(14617)───mydocker(14974)─┬─sh(14978)
           │                         │                               ├─{mydocker}(14975)
           │                         │                               ├─{mydocker}(14976)
           │                         │                               └─{mydocker}(14977)
....
```

构造容器流程图



![img](https://typora-img-xue.oss-cn-beijing.aliyuncs.com/img/resize,w_1440,m_lfit-20240119184657874.jpeg)

### 管道 os.Pipe()

在Go语言中，`os.Pipe`是用于创建一个管道（Pipe）的函数。管道是用于进程间通信的一种机制，允许一个进程将数据写入管道，而另一个进程则可以从管道中读取相同的数据。在`os.Pipe`中，它返回一个包含两个文件描述符的`*os.File`数组，一个用于读取，另一个用于写入。

下面是一个简单的例子，演示如何使用`os.Pipe`：

在Go中，可以使用`os/exec`包来创建子进程，并通过管道进行通信。以下是一个简单的例子，演示如何在不同的Go程序中使用无名管道进行进程通信：

**程序1：写入数据到管道**

```go
package main

import (
	"fmt"
	"os"
	"os/exec"
)

func main() {
	// 创建管道
	reader, writer, err := os.Pipe()
	if err != nil {
		fmt.Println("Error creating pipe:", err)
		return
	}

	// 启动子进程
	cmd := exec.Command("go", "run", "program2.go")
	cmd.Stdout = writer // 将管道的写入端连接到子进程的标准输出

	err = cmd.Start()
	if err != nil {
		fmt.Println("Error starting subprocess:", err)
		return
	}

	// 等待子进程结束
	err = cmd.Wait()
	if err != nil {
		fmt.Println("Error waiting for subprocess:", err)
	}

	reader.Close() // 关闭读取端
}
```

**程序2：从管道读取数据**

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 获取管道的读取端
	reader := os.Stdin

	// 从管道中读取数据
	buffer := make([]byte, 100)
	n, err := reader.Read(buffer)
	if err != nil {
		fmt.Println("Error reading from pipe:", err)
		return
	}

	fmt.Println("Read from pipe:", string(buffer[:n]))
}
```

请注意，在这个例子中，我们启动了一个子进程（程序2），并将其标准输出连接到管道的写入端。主程序（程序1）写入数据到管道，而子程序从管道中读取数据。这是一个基本的进程间通信的例子，你可能需要根据具体情况进行更复杂的处理。

### cmd.ExtraFiles

在Go语言中，`cmd.ExtraFiles` 是一个 `[]*os.File` 类型的切片，它用于将额外的文件描述符（file descriptors）传递给一个新启动的进程。这通常用于将文件或其他 I/O 对象传递给由 `os/exec` 包创建的子进程。

这个属性的意思是会外带着这个文件句柄去创建子进程。为什么叫“外带着”呢？因为1个进程默认会有3个文件描述符，分别是标准输入、标准输出、标准错误。这3个是子进程一创建的时候就会默认带着的，那么外带的这个文件描述符理所当然地就成为了第4个。

在使用 `os/exec` 包创建子进程时，你可以将需要传递给子进程的文件描述符添加到 `cmd.ExtraFiles` 中。这些文件描述符会在子进程启动后变为其标准输入、标准输出等。

以下是一个简单的例子，演示如何使用 `cmd.ExtraFiles`：

```go
package main

import (
	"fmt"
	"os"
	"os/exec"
)

func main() {
	file, err := os.Create("example.txt")
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	file.WriteString("Hello, ExtraFiles!")

	cmd := exec.Command("cat")
	cmd.ExtraFiles = []*os.File{file}

	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Println("Error running command:", err)
		return
	}

	fmt.Println(string(output))
}
```

在这个例子中，我们创建了一个文件 `example.txt`，然后将该文件的文件描述符添加到 `cmd.ExtraFiles` 中。`cmd` 对象表示一个运行的命令，这里我们使用 `cat` 命令来读取传递进来的文件描述符。最后，我们输出命令执行的结果。

### 增加容器资源限制

https://github.com/lin-coco/mydocker/tree/v0.2

实现`mydocker run -it -m 100m -cpuset 1 -cpushare 512 /bin/sh`



![img](https://typora-img-xue.oss-cn-beijing.aliyuncs.com/img/resize,w_1440,m_lfit-20240119184635987.jpeg)

![img](https://typora-img-xue.oss-cn-beijing.aliyuncs.com/img/resize,w_1440,m_lfit-20240119223351360.jpeg)

![img](https://typora-img-xue.oss-cn-beijing.aliyuncs.com/img/resize,w_1440,m_lfit-20240119223336282.jpeg)



## 构建镜像

### busybox

BusyBox是一个集成了许多标准Unix工具和命令的软件工具箱。它旨在提供小型、轻量级的可执行文件，适用于嵌入式系统和资源受限的环境。BusyBox包含了许多常见的命令，如ls、cp、mv、rm等，以及一些用于系统管理的工具。

通常情况下，BusyBox被用于嵌入式Linux系统，其中空间和资源受限，而需要保留足够的功能来进行基本的系统管理和维护任务。由于BusyBox的设计目标是精简和轻量级，因此它能够在资源受限的环境中运行，并占用较小的存储空间。

在某些系统中，BusyBox甚至可以作为替代品提供一系列核心的命令和工具，以减小系统的存储占用。
```bash
# 获取busybox
docker pull busybox
docker run -d busybox top -b
docker export -o busybox.tar [容器id]
tar -xvf busybox.tar -C busybox/
```

> 先拷贝到`/root/busybox`后面要用到

### pivot_root

`pivot_root` 是一个 Linux 系统调用，用于更改一个进程的根文件系统挂载点。这个调用允许将当前根文件系统替换为另一个目录，同时保持进程对文件系统的访问。

在使用 `pivot_root` 之前，通常需要使用 `chroot` 将要作为新根文件系统的目录切换到一个新的根目录。然后，`pivot_root` 可以将这个新的根目录切换为当前进程的根文件系统。

这通常在实现 Linux 系统初始化过程中的初始化ramdisk（initrd）或实现容器技术（如Docker）时使用，以便在运行时切换文件系统的根目录。这种机制允许在运行时动态更改根文件系统，而不需要重新启动系统。

`syscall.PivotRoot` 是 Linux 系统调用 `pivot_root` 在 Go 语言中的封装。它有两个参数：

1. 第一个参数：新的根目录（New Root）
   - 这个参数指定了要成为新的根文件系统的目录。

2. 第二个参数：旧的根目录（Put old root）
   - 它指定了用于挂载新的根文件系统的目录。而不是旧的根文件系统目录

总体而言，`syscall.PivotRoot(".", ".oldroot")` 这行代码的目的是将当前工作目录切换为新的根文件系统，同时将原始的根文件系统移动到 `.oldroot` 目录。

`pivot_root`和`chroot`都是Linux系统中用于改变进程的根文件系统的工具，但它们有一些关键的区别。

1. **chroot:**
   - `chroot`是一个系统调用，也是一个命令行工具，它允许你将进程的根目录更改为一个新的目录，以限制该进程对文件系统的访问。
   - 使用`chroot`后，进程以及其子进程只能看到和访问新的根目录下的文件，无法访问原来的根目录以外的内容。
   - 通常用于创建隔离的环境，如在软件开发、测试或系统维护中。

   ```bash
   chroot /new/root/directory
   ```

2. **pivot_root:**
   
   - `pivot_root`也是一个系统调用，用于更改进程的根文件系统，但它与`chroot`不同，因为它能够在不创建新的进程的情况下切换根文件系统。
   - `pivot_root`通常与`chroot`一起使用，用于移动根文件系统到一个新的目录，并将旧的根文件系统卸载。
   
   ```c
   pivot_root(new_root, put_old);
   ```
   
   - 具体操作可以参考 `man 2 pivot_root`。

总体而言，`chroot`用于在一个进程中创建一个隔离的文件系统环境，而`pivot_root`则更侧重于在一个进程中切换根文件系统，通常与`chroot`一起使用来实现更复杂的环境隔离。

### syscall.Chdir

在Go语言中，`syscall.Chdir` 函数用于改变当前的工作目录。它的作用是将当前工作目录更改为指定的目录。这可以在需要切换工作目录的情况下使用，例如，当你需要在程序运行时访问特定路径下的文件或执行特定操作时。

以下是 `syscall.Chdir` 函数的基本使用示例：

```go
package main

import (
	"fmt"
	"os"
	"syscall"
)

func main() {
	// 获取当前工作目录
	currentDir, err := os.Getwd()
	if err != nil {
		fmt.Println("Error getting current directory:", err)
		return
	}

	fmt.Println("Current working directory:", currentDir)

	// 改变工作目录到指定路径
	newDir := "/path/to/directory"
	err = syscall.Chdir(newDir)
	if err != nil {
		fmt.Println("Error changing directory:", err)
		return
	}

	// 获取改变后的工作目录
	newCurrentDir, err := os.Getwd()
	if err != nil {
		fmt.Println("Error getting new current directory:", err)
		return
	}

	fmt.Println("New working directory:", newCurrentDir)
}
```

在这个例子中，程序首先获取当前工作目录，然后使用 `syscall.Chdir` 将工作目录更改为指定路径，最后再次获取新的工作目录并输出。这对于需要在不同目录下执行操作的情况非常有用。

`syscall.Chdir` 函数用于改变当前进程的工作目录。它会影响调用该函数的整个程序的工作目录，因此在程序运行时，当前进程的工作目录会被更改为指定的目录。这意味着在接下来的文件操作或其他相关操作中，程序将以新的工作目录为基础进行处理。

### mount bind(type)

在上下文中，"bind" 通常指的是文件系统中的一种挂载方式，称为 "bind mount"。Bind mount 是将一个已经存在的目录或文件挂载到另一个目录下的操作。这种挂载方式使得两个目录（源目录和目标目录）共享相同的文件和子目录，而不是在目标目录中创建源目录的副本。

在 Linux 中，你可以使用 `mount` 命令进行 bind mount 操作，或者在程序中使用相关的系统调用，如 `syscall.Mount`。

在 `syscall.Mount` 的 `flags` 参数中，使用 `MS_BIND` 标志可以实现 bind mount。以下是一个简单的例子：

```go
package main

import (
	"syscall"
)

func main() {
	source := "source_directory"
	target := "target_directory"
	flags := uintptr(syscall.MS_BIND | syscall.MS_REC)

	err := syscall.Mount(source, target, "", flags, "")
	if err != nil {
		panic(err)
	}

	// 在这里执行 bind mount 后的操作

	err = syscall.Unmount(target, syscall.MNT_DETACH)
	if err != nil {
		panic(err)
	}
}
```

这个例子中，`source_directory` 被 bind mount 到 `target_directory`，两者共享相同的文件和目录。 `syscall.Unmount` 被用于卸载 bind mount，在不再需要时执行。



```go
syscall.Mount(root, root, "bind", syscall.MS_BIND|syscall.MS_REC, "")
```

在你提供的代码中，使用了 `syscall.Mount` 进行 bind mount 操作，将 `root` 目录绑定到它自己。理论上，这是合法的，但通常情况下这种操作没有太多实际用途。

当你将一个目录 bind mount 到自己时，本质上并没有改变文件系统的结构。两者共享相同的内容，但在文件系统上并没有创建新的挂载点。这意味着，对其中一个目录的更改会立即反映在另一个目录上，因为它们实际上是同一个文件系统中的同一部分。

这样的操作可能在某些特殊情况下有其用途，但通常情况下，人们会使用 bind mount 将一个目录挂载到另一个不同的目录，以实现文件系统层次结构的变化或者将文件系统的一部分移动到其他位置。在绝大多数情况下，将目录 bind mount 到自己的行为并不常见。

### tmpfs

在Linux系统中，`tmpfs` 是一种虚拟的内存文件系统，它允许将一部分系统内存用作文件系统。`tmpfs` 不依赖于硬盘上的任何实际存储，而是存在于系统的内存中。因此，当系统重新启动时，`tmpfs` 中的数据将丢失。

### 使用busybox创建容器

https://github.com/lin-coco/mydocker/tree/v0.3

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -it sh
{"level":"info","msg":"init come on","time":"2024-02-21T16:17:28+08:00"}
{"level":"info","msg":"current location is /root/busybox","time":"2024-02-21T16:17:28+08:00"}
/ # pwd
/
/ # ls
bin    dev    etc    home   lib    lib64  proc   root   sys    tmp    usr    var
/ # cd root
~ # ls
~ # mount
/dev/vda3 on / type ext4 (rw,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev type tmpfs (rw,nosuid,mode=755,inode64)
~ # 
~ # 
~ # 
```

### root文件系统

在计算机领域中，"root文件系统"通常指的是Linux系统中的根文件系统，它是文件系统的顶层目录，表示为"/"。这个根目录包含了整个文件系统的层次结构，所有其他目录和文件都位于这个根目录下面。在类Unix系统中，包括Linux，根文件系统是整个文件系统层次结构的起点。

在你作为后端开发人员使用Go语言进行开发时，你可能会涉及到文件系统的操作，例如读取或写入文件。在这种情况下，你需要了解根文件系统及其层次结构，以便正确定位和处理文件。

```bash
/dev/vda3 on / type ext4 (rw,relatime)
```

这是指定的Linux系统中的根文件系统。在给出的信息中，"/dev/vda3" 是根文件系统的设备，"/" 表示它是挂载点。文件系统类型为 ext4，而括号中的选项 "rw,relatime" 指定了该文件系统的挂载选项，其中 "rw" 表示读写（read-write），"relatime" 表示相对访问时间，用于文件访问时间戳。所以，这个条目表明 "/dev/vda3" 设备上的 ext4 文件系统被挂载到根目录 "/"。

所有其他文件系统也都是挂载在其下面

在Linux系统中，其他文件系统会被挂载到根文件系统的不同子目录下。这样的设计使得不同的存储设备或分区可以被整合到一个统一的目录结构中。这些挂载点充当了不同文件系统的入口，让它们在整个系统中以层次结构的形式组织。

例如，如果有一个独立的分区用于存储用户数据，它可能会被挂载到 "/home" 目录下。同样，如果有一个用于存储临时文件的分区，它可能会被挂载到 "/tmp" 目录下。这种方式有助于管理系统中不同用途的存储空间。你可以使用 `df -h` 命令查看当前系统上所有挂载点及其使用情况。

### 使用overlay包装busybox

https://github.com/lin-coco/mydocker/tree/v0.4

https://github.com/xianlubird/mydocker/issues/62

```sh
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -it sh
{"level":"info","msg":"init come on","time":"2024-02-23T11:05:06+08:00"}
{"level":"info","msg":"current location is /root/writedocker/overlay/mnt","time":"2024-02-23T11:05:06+08:00"}
/ # 
/ # ls
bin    dev    etc    home   lib    lib64  proc   root   sys    tmp    usr    var
/ # mount
overlay on / type overlay (rw,relatime,lowerdir=/root/writedocker/overlay/lowerLayer,upperdir=/root/writedocker/overlay/upperLayer,workdir=/root/writedocker/overlay/workerLayer)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev type tmpfs (rw,nosuid,mode=755,inode64)
/ # cd ..
/ # ls
bin    dev    etc    home   lib    lib64  proc   root   sys    tmp    usr    var
```



### 实现volume数据卷

主机视角：将主机某目录挂载到mnt某目录下

https://github.com/lin-coco/mydocker/tree/v0.5

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -it -v /root/dataVolume:/container/dataVolume sh
{"level":"info","msg":"init come on","time":"2024-02-23T13:42:20+08:00"}
{"level":"info","msg":"current location is /root/writedocker/overlay/mnt","time":"2024-02-23T13:42:20+08:00"}
/ # ls
bin        container  dev        etc        home       lib        lib64      proc       root       sys        tmp        usr        var
/ # mount
overlay on / type overlay (rw,relatime,lowerdir=/root/writedocker/overlay/lowerLayer,upperdir=/root/writedocker/overlay/upperLayer,workdir=/root/writedocker/overlay/workerLayer)
/dev/vda3 on /container/dataVolume type ext4 (rw,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev type tmpfs (rw,nosuid,mode=755,inode64)
/ # echo "container write\n" >> /container/dataVolume/test.txt
/ # cat /container/dataVolume/test.txt
container write\n
/ # exit
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# cat /root/dataVolume/test.txt 
container write\n
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# echo "host write\n" >> /root/dataVolume/test.txt
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# cat /root/dataVolume/test.txt 
container write\n
host write\n
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -it -v /root/dataVolume:/container/dataVolume sh
{"level":"info","msg":"init come on","time":"2024-02-23T13:45:08+08:00"}
{"level":"info","msg":"current location is /root/writedocker/overlay/mnt","time":"2024-02-23T13:45:08+08:00"}
/ # cat /container/dataVolume/test.txt 
container write\n
host write\n
/ # exit
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# 

```

### 实现简单镜像打包

就是压缩mnt目录

https://github.com/lin-coco/mydocker/tree/v0.6

打开一个终端

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -it sh
{"level":"info","msg":"init come on","time":"2024-02-23T14:10:42+08:00"}
{"level":"info","msg":"current location is /root/writedocker/overlay/mnt","time":"2024-02-23T14:10:42+08:00"}
/ # 
/ # 

```

打开另一个终端

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker commit image
{"level":"info","msg":"/root/image.tar","time":"2024-02-23T14:10:51+08:00"}
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ls /root
bochs  bochs-2.6.2  bochs-2.6.2.tar.gz  busybox  code  dataVolume  go  image.tar  my_chroot  mydocker  snap  writedocker
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# mkdir /root/untar
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# cd /root/untar
root@iZuf6j3esdg00724fgc2r5Z:~/untar# ls
root@iZuf6j3esdg00724fgc2r5Z:~/untar# tar -xvf /root/image.tar 
......
root@iZuf6j3esdg00724fgc2r5Z:~/untar# ls
bin  dev  etc  home  lib  lib64  proc  root  sys  tmp  usr  var
root@iZuf6j3esdg00724fgc2r5Z:~/untar# 

```

## 构建容器进阶

### tabwriter

在Go语言中，`tabwriter` 是一个标准库包，它提供了用于格式化输出文本以使其整齐对齐的功能。这个包主要用于创建表格数据，其中列使用制表符或空格进行对齐。

要使用 `tabwriter` 包，首先需要导入它，然后使用其 `NewWriter` 函数来创建一个新的 `*tabwriter.Writer` 对象。这个对象可以像普通的 `io.Writer` 一样使用，但会在写入时自动进行对齐处理。

下面是一个使用 `tabwriter` 包创建简单表格的示例：

```go
package main  
  
import (  
	"fmt"  
	"log"  
	"os"  
	"text/tabwriter"  
)  
  
func main() {  
	// 创建tabwriter的Writer对象  
	// 参数分别为：输出的io.Writer，制表符的最小宽度，制表符和列之间的填充字符，列之间的对齐方式（'align'参数），制表符宽度，是否删除每行开头的空格，是否在行末添加换行符  
	w := tabwriter.NewWriter(os.Stdout, 0, 8, 1, '\t', 0)  
  
	// 写入表头  
	fmt.Fprintln(w, "NAME\tAGE\tOCCUPATION")  
  
	// 写入表格数据  
	people := []struct {  
		Name    string  
		Age     int  
		Job     string  
	}{  
		{"Alice", 31, "Engineer"},  
		{"Bob", 27, "Doctor"},  
		{"Charlie", 35, "Lawyer"},  
	}  
  
	for _, p := range people {  
		fmt.Fprintf(w, "%s\t%d\t%s\n", p.Name, p.Age, p.Job)  
	}  
  
	// 刷新缓冲区，确保所有数据都被写入  
	if err := w.Flush(); err != nil {  
		log.Fatal(err)  
	}  
}
```

在上面的例子中，`NewWriter` 函数的参数包括：

- 第一个参数是 `io.Writer` 接口的实现，这里我们使用了 `os.Stdout`，表示输出到标准输出。
- 第二个参数是制表符的最小宽度，如果列的内容长度小于这个宽度，则使用空格填充到该宽度。
- 第三个参数是列之间的填充字符，这里我们使用了空格。
- 第四个参数是列的对齐方式，可以是 `tabwriter.AlignLeft`、`tabwriter.AlignCenter` 或 `tabwriter.AlignRight`。
- 第五个参数是制表符的宽度，这里我们使用了默认的制表符宽度（即 `\t` 的宽度）。
- 第六个参数控制是否删除每行开头的空格。
- 最后一个参数控制是否在行末添加换行符。

最后，使用 `Flush` 方法来确保所有缓冲的数据都被写入到 `io.Writer` 中。

当你运行上面的程序时，它将在控制台上打印出格式化的表格数据。



### 实现容器的后台运行

https://github.com/lin-coco/mydocker/tree/v0.7

容器，在操作系统看来，其实就是一个进程。当前运行命令的mydocker 是主进程，容器是被当前mydocker进程fork出来的子进程。子进程的结束和父进程的运行是一个异步的过程，即父进程永远不知道子进程到底什么时候结束。如果创建子进程的父进程退出，那么这个子进程就成了没人管的孩子，俗称孤儿进程。为了避免孤儿进程退出时无法释放所占用的资源而僵死，进程号为1的进程init就会接受这些孤儿进程。

> 打开一个终端

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -d top
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# 
```

> 打开另一个终端

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/overlay# ps -ef
root       22867       1  0 14:55 pts/0    00:00:00 top
root       22873   18885  0 14:56 pts/1    00:00:00 ps -ef
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/overlay# kill 22867
我们还发现，overlay文件系统被回收了，进程还在运行
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/overlay# ls
lowerLayer
```



### 孤儿进程与僵尸进程

让我更清楚地解释一下孤儿进程和僵尸进程的区别：

1. **孤儿进程（Orphan Process）**：
   - 孤儿进程是指其父进程已经终止的进程。通常情况下，当一个进程终止时，它的子进程会被操作系统收养，即父进程退出时，子进程的新父进程会被设置为init进程（进程号为1）。这样做的目的是确保没有进程被丢弃，而是被安全地回收。
   - 举例来说，假设进程A创建了进程B，然后进程A终止了。此时，进程B会成为一个孤儿进程，而操作系统会将其父进程设置为init进程。因此，进程B不再是孤儿进程，而是init进程的子进程。

2. **僵尸进程（Zombie Process）**：
   - 僵尸进程是指已经完成执行任务，但其父进程尚未对其进行善后处理（如调用wait()系统调用以获取其退出状态）的进程。当一个进程结束运行时，它会向其父进程发送一个信号，告诉父进程它已经退出了。父进程接收到这个信号后，应该调用wait()或类似的系统调用来获取子进程的退出状态，然后做必要的清理工作。如果父进程没有及时对子进程进行善后处理，子进程就会成为僵尸进程。
   - 举例来说，如果进程A创建了进程B，并且进程B终止了，但进程A没有调用wait()来获取进程B的退出状态，那么进程B就会成为一个僵尸进程。

综上所述，孤儿进程和僵尸进程是两个不同的概念。孤儿进程指的是父进程终止后的子进程，而僵尸进程是指父进程尚未对其进行善后处理的已经终止的子进程。

- 在Unix和类Unix系统中，孤儿进程是指其父进程已经终止的进程。当一个进程的父进程终止时，如果操作系统的进程1（通常是init或systemd等）接管了它，那么这个进程不再是孤儿进程。相反，它成为了由进程1所接管的子进程。因此，虽然它的父进程终止了，但它并不被称为孤儿进程。

- 僵尸进程是指已经完成执行任务，但其父进程尚未对其进行善后处理（如调用wait()系统调用以获取其退出状态）的进程。当一个进程结束运行时，它会向其父进程发送一个信号，告诉父进程它已经退出了。父进程接收到这个信号后，应该调用wait()或类似的系统调用来获取子进程的退出状态，然后做必要的清理工作。

  如果父进程没有及时对子进程进行善后处理，子进程就会成为僵尸进程。尽管僵尸进程不再执行任何代码，但其进程表项仍然存在于系统的进程表中，因为其父进程还没有接收到退出状态。过多的僵尸进程可能会导致系统资源浪费。

  当然可以。以下是一个使用Go语言创建僵尸进程的简单示例：

  ```go
  package main
  
  import (
      "fmt"
      "os"
      "os/exec"
      "syscall"
      "time"
  )
  
  func main() {
      // 创建子进程
      cmd := exec.Command("sleep", "10")
      cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true} // 设置新进程组，以防止其成为init的子进程
  
      // 启动子进程
      if err := cmd.Start(); err != nil {
          fmt.Printf("启动子进程失败: %s\n", err)
          return
      }
  
      fmt.Printf("子进程PID: %d\n", cmd.Process.Pid)
  
      // 等待一段时间，模拟父进程不对子进程进行善后处理
      time.Sleep(5 * time.Second)
  
      // 程序退出，父进程结束，子进程成为僵尸进程
      fmt.Println("父进程结束")
  
      // 不对子进程进行善后处理，让其成为僵尸进程
  }
  ```

  在此示例中，我们使用`exec.Command`创建一个子进程，该子进程执行`sleep 10`命令（即休眠10秒）。然后，父进程在启动子进程后等待5秒，之后退出。在父进程退出后，子进程仍然在运行，但没有父进程负责回收它的资源，因此它会成为一个僵尸进程。

  请注意，为了防止子进程成为init进程的子进程而不是父进程的子进程，我们使用了`SysProcAttr`来设置新的进程组。



### 实现查看运行中容器

https://github.com/lin-coco/mydocker/tree/v0.8

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -d top
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -d --name bird top
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ls /var/run/mydocker
6089750648  bird
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# tree /var/run/mydocker
/var/run/mydocker
├── 6089750648
│   └── config.json
└── bird
    └── config.json

2 directories, 2 files
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# cat /var/run/mydocker/6089750648/config.json 
{"pid":"52109","id":"6089750648","name":"6089750648","command":"top","createTime":"2024-02-28 10:59:00","status":"running"}root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# cat /var/run/mydocker/bird/config.json 
{"pid":"52119","id":"0191862551","name":"bird","command":"top","createTime":"2024-02-28 10:59:14","status":"running"}root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# 
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker ps
ID           NAME         PID         STATUS      COMMAND     CREATED
6089750648   6089750648   52109       running     top         2024-02-28 10:59:00
0191862551   bird         52119       running     top         2024-02-28 10:59:14
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ps -ef
...
root       52109       1  0 10:58 pts/0    00:00:00 top
root       52119       1  0 10:59 pts/0    00:00:00 top
root       52143   51653  0 11:01 pts/0    00:00:00 ps -ef
```

### 实现查看容器日志

https://github.com/lin-coco/mydocker/tree/v0.9

我们会将容器进程的标准输出挂载到`/var/run/mydocker/容器名/container.log`文件中，这样就可以在调用mydocker logs的时候去读取这个文件，并将进程内的标准输出打印出来。

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -d --name bird top
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# tree /var/run/mydocker/bird
/var/run/mydocker/bird
├── config.json
Mem: 1524980K used, 223720K free, 2616K shrd, 153160K buff, 1016108K cached
CPU:  0.2% usr  0.0% sys  0.0% nic 99.7% idle  0.0% io  0.0% irq  0.0% sirq
Load average: 0.10 0.04 0.00 1/225 4
  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# 
```

### setns

setns()系统调用是Linux内核在3.0版本中引入的一个新的系统调用。它允许一个进程切换到另一个命名空间中执行，从而实现进程间的命名空间隔离和共享。

setns()系统调用的原型如下：

```c
int setns(int fd, int nstype);
```

其中，`fd`参数是一个文件描述符，它指向要切换到的目标命名空间的路径。`nstype`参数指定了要切换到的命名空间的类型，例如PID、网络、挂载等。如果不指定`nstype`参数，则默认为0，表示自动检测`fd`指向的命名空间的类型。

setns()系统调用的主要作用是实现进程间的命名空间隔离和共享。在Linux中，每个进程都有一个自己的命名空间，包括PID命名空间、网络命名空间、挂载命名空间等。通过setns()系统调用，一个进程可以切换到另一个进程的命名空间中执行，从而访问该命名空间中的资源。这对于实现容器化技术、进程隔离等场景非常有用。

需要注意的是，**setns()系统调用不会将调用者本身放入目标命名空间中，而是将调用者后续创建的子进程放入目标命名空间中**。此外，unshare()系统调用和setns()系统调用不会将调用者放在创建的命名空间中，而是将调用者后续创建的子进程放入命名空间中。

总的来说，setns()系统调用是Linux内核提供的一种机制，用于实现进程间的命名空间隔离和共享。通过该系统调用，进程可以切换到另一个命名空间中执行，从而访问该命名空间中的资源。这对于实现容器化技术、进程隔离等场景非常有用。



对于Mount Namespace来说，`setns()` 系统调用确实允许一个进程（包括其所有线程）切换到另一个Mount Namespace。当你对一个进程调用 `setns()` 并指定一个Mount Namespace的文件描述符时，整个进程（包括其所有线程）都会进入新的Mount Namespace。

然而，有一点需要澄清：虽然整个进程会进入新的Mount Namespace，但这并不意味着进程中的所有线程会同时执行`setns()`调用。实际上，只有一个线程（通常是调用`setns()`的线程）执行这个系统调用。当这个调用成功时，整个进程（包括其所有线程）都会“看到”新的Mount Namespace。

这意味着，如果你在调用`setns()`之后在新的Mount Namespace中挂载或卸载文件系统，这些改变将影响整个进程的所有线程，因为它们现在共享同一个Mount Namespace。

如果你有一个多线程进程，并且你希望所有线程都能够在新的Mount Namespace中运行，你只需要在一个线程中调用`setns()`即可。之后，所有线程都将“看到”新的Mount Namespace，并且可以在其中执行文件系统操作。

然而，需要注意的是，如果你在多线程环境中使用`setns()`并且你的程序依赖于特定的Mount Namespace设置，你需要确保所有线程都能够适应新的Mount Namespace环境，并且正确处理任何可能的竞态条件或同步问题。

总之，多线程进程可以使用`setns()`进入Mount Namespace，但整个进程（包括其所有线程）都会受到影响。你只需要在一个线程中调用`setns()`，之后所有线程都将共享新的Mount Namespace。

### Cgo

Go语言的cgo功能是一种机制，允许Go程序与C语言代码进行交互。通过cgo，Go程序可以直接调用C语言的函数，同时C语言代码也可以调用Go程序中的函数。这使得Go程序能够利用现有的C语言库或代码，从而扩展其功能和灵活性。

使用cgo的过程相对简单。首先，在Go代码中，需要使用`import "C"`语句来启用cgo功能。然后，可以通过在Go文件中引入C语言的头文件，使得Go代码能够访问C语言中的函数和数据类型。在Go代码中，可以使用`C.`前缀来调用C语言中的函数。

此外，cgo还支持在Go代码中自定义C语言代码，并通过`//export`注释导出Go函数以供C语言代码调用。这使得Go和C之间的交互更加灵活和方便。

需要注意的是，要使用cgo功能，需要安装C/C++构建工具链，例如GCC或MinGW。同时，需要确保环境变量`CGO_ENABLED`被设置为1，以启用cgo功能。

总的来说，Go语言的cgo功能为Go与C语言之间的交互提供了一种方便和灵活的方式，使得Go程序能够充分利用现有的C语言资源和库，从而扩展其功能和性能。

```go
import "C"// 必须紧贴c代码的下面
```

### 实现进入容器Namespace

https://github.com/lin-coco/mydocker/tree/v0.10

```bash
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run --name bird -d top
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker ps
ID           NAME        PID         STATUS      COMMAND     CREATED
8392620397   bird        67012       running     top         2024-02-28 19:00:17
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker exec bird sh
/ # ps -ef
PID   USER     TIME  COMMAND
    1 root      0:00 top
    6 root      0:00 sh
    7 root      0:00 ps -ef
/ # mount
overlay on / type overlay (rw,relatime,lowerdir=/root/writedocker/overlay/lowerLayer,upperdir=/root/writedocker/overlay/upperLayer,workdir=/root/writedocker/overlay/workerLayer)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev type tmpfs (rw,nosuid,mode=755,inode64)
/ # ls
bin    dev    etc    home   lib    lib64  proc   root   sys    tmp    usr    var
/ # 
/ # exit
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker#
```



### 实现停止容器

https://github.com/lin-coco/mydocker/tree/v0.11

### docker 镜像和容器的存储路径

```sh
$ docker info
Storage Driver: overlay2
Docker Root Dir: /var/lib/docker
```

镜像保存路径：`/var/lib/docker/overlay2`

容器文件系统层的唯一标识符：`/var/lib/docker/overlay2/2a2de9a4d8cff48ee19934e4b40ae0bea39c992e965194c5aec9e6219d180d9d`



**/var/run和/var/lib目录区别**

`/var/run` 和 `/var/lib` 是两个不同的目录，各自有不同的用途：

1. **`/var/run` 目录：**
   - 通常用于存储运行时期间生成的临时运行时文件，如 PID 文件（进程ID文件）等。
   - 这个目录下的文件通常在系统重新启动时会被清除，因为它们是临时的。

2. **`/var/lib` 目录：**
   - 用于存储系统和服务的可变数据，包括数据库文件、状态信息等。
   - 与 `/var/run` 不同，`/var/lib` 目录下的数据通常是持久的，不会在系统重新启动时被删除。
   - Docker 镜像和容器的数据通常存储在 `/var/lib/docker` 下，其中包含镜像、容器文件系统、网络配置等信息。

在 Docker 的上下文中：
- `/var/run/docker.pid` 存储 Docker 守护进程的 PID 文件。
- `/var/lib/docker` 存储 Docker 的持久化数据，包括镜像、容器数据等。

总体而言，`/var/run` 通常包含运行时生成的临时文件，而 `/var/lib` 包含持久化的数据。



Docker 镜像通常存储在 Docker 主机的 `/var/lib/docker` 目录下。其中，镜像的具体位置为 `/var/lib/docker/image/overlay2` 或者类似的路径，具体取决于你的存储驱动。

容器文件系统存储在容器的可写层，通常位于 `/var/lib/docker/overlay2` 或相应的存储驱动目录下。容器文件系统的具体路径会包含一个长字符串，代表容器的 ID。

请注意，具体路径可能会因为 Docker 版本、操作系统和配置而有所不同。

### 实现删除容器

https://github.com/lin-coco/mydocker/tree/v0.11

### 实现通过容器制造镜像

https://github.com/lin-coco/mydocker/tree/v0.12

```sh
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker ps
ID          NAME        PID         STATUS      COMMAND     CREATED
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -d --name container1 -v /root/from1:/to1 top
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -d --name container2 -v /root/from2:/to2 top
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker ps
ID           NAME         PID         STATUS      COMMAND     CREATED
4625406556   container1   81929       running     top         2024-03-02 23:08:38
4705063042   container2   81945       running     top         2024-03-02 23:08:59
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ls /root
bochs  bochs-2.6.2  bochs-2.6.2.tar.gz  busybox  code  dataVolume  from1  from2  go  image.tar  my_chroot  mydocker  snap  untar  writedocker
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ls /var/lib/mydocker/overlay/container1/
lower  mnt  upper  worker
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ls /var/lib/mydocker/overlay/container2/
lower  mnt  upper  worker
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ls ls /var/lib/mydocker/overlay/container2/lower/
ls: cannot access 'ls': No such file or directory
/var/lib/mydocker/overlay/container2/lower/:
bin  dev  etc  home  lib  lib64  proc  root  sys  tmp  usr  var
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ls /var/lib/mydocker/overlay/container1/lower/
bin  dev  etc  home  lib  lib64  proc  root  sys  tmp  usr  var
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker exec container1 sh
/ # ls
bin    dev    etc    home   lib    lib64  proc   root   sys    tmp    to1    usr    var
/ # echo "hello container1" >> /to1/test1.txt
/ # echo -e "hello container1, to1-1, test1" >> /to1-1/test1.txt
sh: can't create /to1-1/test1.txt: nonexistent directory
/ # mkdir to1-1
/ # echo -e "hello container1, to1-1, test1" >> /to1-1/test1.txt
/ # ls
bin    dev    etc    home   lib    lib64  proc   root   sys    tmp    to1    to1-1  usr    var
/ # exit
enter_namespace start!root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# cd ~
root@iZuf6j3esdg00724fgc2r5Z:~# ls
bochs  bochs-2.6.2  bochs-2.6.2.tar.gz  busybox  code  dataVolume  from1  from2  go  image.tar  my_chroot  mydocker  snap  untar  writedocker
root@iZuf6j3esdg00724fgc2r5Z:~# ls from1
test1.txt
root@iZuf6j3esdg00724fgc2r5Z:~# cat from
from1/ from2/ 
root@iZuf6j3esdg00724fgc2r5Z:~# cat from1/test1.txt 
hello container1
root@iZuf6j3esdg00724fgc2r5Z:~# ./mydocker commit container1 image1
-bash: ./mydocker: Is a directory
root@iZuf6j3esdg00724fgc2r5Z:~# cd ~/writedocker/mydocker
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker commit container1 image1
{"level":"info","msg":"/root/image1.tar","time":"2024-03-02T23:15:53+08:00"}
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker stop container1
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker rm container1
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker ps
ID           NAME         PID         STATUS      COMMAND     CREATED
4705063042   container2   81945       running     top         2024-03-02 23:08:59
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# cat /root/from1/test1.txt 
hello container1
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# go build
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# mv /root/image
image.tar   image1.tar  
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# mv /root/image1 /var/lib/mydocker/overlay/image
mv: cannot stat '/root/image1': No such file or directory
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# mv /root/image1.tar /var/lib/mydocker/overlay/image
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ls /var/lib/mydocker/overlay/image
busybox.tar  image1.tar
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# go build
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydcoker run -d --name container3 -v /root/from1:/to1 image1 top
-bash: ./mydcoker: No such file or directory
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker run -d --name container3 -v /root/from1:/to1 image1 top
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker ps
ID           NAME         PID         STATUS      COMMAND     CREATED
4705063042   container2   81945       running     top         2024-03-02 23:08:59
3321186914   container3   82523       running     top         2024-03-02 23:33:45
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker exec container3 sh
/ # ls
bin    dev    etc    home   lib    lib64  proc   root   sys    tmp    to1    to1-1  usr    var
/ # cat to1/test1.txt 
hello container1
/ # cat to1-1/test1.txt 
hello container1, to1-1, test1
/ # echo -e "hello container3" >> /to1/test2.txt
/ # cat /to1/test2.txt
hello container3
/ # exit
enter_namespace start!root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ls /root/from1
test1.txt  test2.txt
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# cat /root/from1/test2.txt 
hello container3
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# 
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker ps
ID           NAME         PID         STATUS      COMMAND     CREATED
4705063042   container2   81945       running     top         2024-03-02 23:08:59
3321186914   container3   82523       running     top         2024-03-02 23:33:45
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker stop container2
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker stop container3
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker rm container2
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker rm container3
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# ./mydocker ps
ID          NAME        PID         STATUS      COMMAND     CREATED
root@iZuf6j3esdg00724fgc2r5Z:~/writedocker/mydocker# 


```

### 实现容器指定环境变量运行

https://github.com/lin-coco/mydocker/tree/v0.13



## 容器网络

### 网络虚拟化技术

我们都知道，Linux实际是通过网络设备去操作和使用网卡的，系统装了一个网卡之后会为其生成一个网络设备实例，比如eth0。而随着网络虚拟化技术的发展，Linux支持创建出虚拟化的设备，可以通过虚拟化设备的组合实现多种多样的功能和网络拓扑。常见的虚拟化设备有Veth、 Bridge、802.1.q VLAN device、TAP，这里主要介绍构建容器网络要用到的Veth和Bridge。

### ip 命令总结

ip命令是用来配置网络设备、ip地址、路由等网络相关信息等强大工具

#### ip link

管理网络接口

##### 创建 veth pair

1. 创建一对veth

   ```sh
   $ ip link add veth0 type veth peer name veth1
   ```

##### 查看 veth pair

1. 查看所有网络接口

   ```sh
   $ ip link show
   ```

2. 查看其中一个

   ```sh
   $ ip link show eth0
   ```

3. 仅查看veth pair

   ```sh
   $ ip link show type veth
   ```

##### 启动veth

1. 启动veth

   ```sh
   $ ip link set veth0 up
   ```

##### 将veth一端分配netns中

1. 分配到netns中

   ```sh
   $ ip link set veth1 netns test-ns
   ```

##### 删除 veth

1. 删除虚拟网卡

   ```sh
   $ ip link delete veth0
   ```

##### 创建bridge网桥

1. 创建网桥

   ```sh
   $ ip link add br0 type bridge
   ```

##### 查看bridge网桥

1. 查看网桥

   ```sh
   $ ip link show type bridge
   ```

##### 将bridge与veth相连

1. 相连bridge与veth

   ```sh
   $ ip link set veth1 master br0
   ```

##### 查看网桥连接状态

1. 查看网桥连接状态

   ```sh
   # 需要先安装一个工具
   $ apt install bridge-utils
   $ brctl show br0
   $ brctl show
   ```

   

##### 启动网桥

1. 启动bridge

   ```sh
   $ ip link set br0 up
   ```

##### 删除bridge网桥

1. 删除网桥

   ```sh
   $ ip link del br0
   ```



#### ip netns

管理网络命名空间

##### 查看 netns

1. 列出所有网络命名空间

   ```sh
   $ ip netns list
   $ ip netns show
   ```

2. 查看网络命名空间中的详细信息

   ```sh
   $ ip netns show test-ns
   ```

##### 在netns中执行命令

1. 执行命令

   ```sh
   $ ip netns exec test-ns ...
   ```

##### 删除netns

1. 删除网络命名空间

   ```sh
   $ ip netns delete test-ns
   ```

#### ip addr

管理IP地址

##### 查看网卡的地址

1. 查看当前的网络接口配置

   ```sh
   $ ip addr show
   ```

2. 仅查看veth pair

   ```sh
   $ ip addr show type veth
   ```

##### 添加网卡的地址

一个网卡可以拥有多个IP地址，这被称为多IP地址（Multiple IP Addresses）

1. 添加ip地址

   ```sh
   $ ip addr add 192.168.1.3/24 dev veth0
   ```

##### 删除网卡的ip地址

一个网卡可以拥有多个IP地址，这被称为多IP地址（Multiple IP Addresses）

1. 禁用ip地址

   ```sh
   $ ip adde del 192.168.1.1/24 dev veth0
   ```



#### ip route

管理路由表

##### 查看路由表

1. 查看完整路由表

   ```sh
   $ ip route show
   ```

2. 查看主机的默认路由

   ```sh
   $ ip route show default
   ```

3. 显示目标地址的路由信息

   ```sh
   $ ip route get 8.8.8.8
   ```

4. 显示本地路由表：用于处理本机上的数据包

   ```sh
   $ ip route show table local
   ```

##### 添加路由规则

1. 添加路由规则

   ```sh
   $ ip route add <destination_network> via <gateway> dev <interface_name>
   $ ip route add 192.168.1.0/24 via 192.168.0.1 dev eth0
   ```

   > - `<destination_network>` 是目标网络的IP地址和子网掩码，如 `192.168.1.0/24`。
   > - `<gateway>` 是下一跳的IP地址，即将数据包传递给该IP地址来到达目标网络。
   > - `<interface_name>` 是数据包出口的网络接口，比如 `eth0`。

##### 删除路由规则

1. 删除路由规则

   ```sh
   $ ip route del <destination_network>
   $ sudo ip route del 192.168.1.0/24
   ```

   > - `<destination_network>` 是要删除的目标网络的IP地址和子网掩码。

### Linux iptables

https://www.jianshu.com/p/ee4ee15d3658

iptables是Linux下面的包过滤防火墙

#### 规则表和链

- 四表是指iptables的功能，iptables规则表有
  - filter：过滤规则表，控制数据包是否允许进入以及转发，可以控制的链路有INPUT、FORWORD、OUTPUT
  - nat：地址转换规则表，控制数据包中地址转换，可以控制的链路有PREROUTING、OUTPUT、POSTROUTING
  - mangle：修改数据标记位规则表，修改数据包中的原数据，可以控制的链路有PREROUTING、INPUT、OUTPUT、FORWORD、POSTROUTING
  - raw：跟踪数据表规则表，控制nat表中连续追踪机制的启用状态，可以控制的链路有PREOUTING、OUTPUT
- 五链是数据包传播的路径，每一个链中可以有一个或多个规则，从第一条规则开始检查，当数据包满足所定义的条件，就按所定义的方法处理该数据包，否则将继续检查吓一跳规则，如果不匹配任一规则，就会按照默认的策略处理：

![img](https://upload-images.jianshu.io/upload_images/7775566-5ec887df41cf1861.png?imageMogr2/auto-orient/strip|imageView2/2/w/749)

规则表之间的优先顺序：

Raw——mangle——nat——filter

#### iptables传输数据包的过程

1. 当一个数据包进入网卡时，它首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去。
2. 如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过OUTPUT链，然后到达POSTROUTING链输出。
3. 如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过FORWARD链，然后到达POSTROUTING链输出。

#### 管理和设置iptables规则

![img](https://upload-images.jianshu.io/upload_images/7775566-d1ad7de240451282.png?imageMogr2/auto-orient/strip|imageView2/2/w/729)



![img](https://upload-images.jianshu.io/upload_images/7775566-fb35d0a138063159.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/690)

![img](https://upload-images.jianshu.io/upload_images/7775566-736f5a5882a69420.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/690)

#### iptables命令的管理控制选项

-A 在指定链的末尾添加（append）一条新的规则

-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除

-I 在指定链中插入（insert）一条新的规则，默认在第一行添加

-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换

-L 列出（list）指定链中所有的规则进行查看

-E 重命名用户定义的链，不改变链本身

-F 清空（flush）

-N 新建（new-chain）一条用户自己定义的规则链

-X 删除指定表中用户自定义的规则链（delete-chain）

-P 设置指定链的默认策略（policy）

-Z 将所有表的所有链的字节和数据包计数器清零

-n 使用数字形式（numeric）显示输出结果

-v 查看规则表详细信息（verbose）的信息

-V 查看版本(version)

-h 获取帮助（help）

#### 防火墙处理数据包的四种方式

ACCEPT 允许数据包通过

DROP 直接丢弃数据包，不给任何回应信息

REJECT 拒绝数据包通过，必要时会给数据发送端一个响应的信息。

LOG在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则

#### iptables防火墙规则的保存与恢复

iptables-save把规则保存到文件中，再由目录rc.d下的脚本（/etc/rc.d/init.d/iptables）自动装载

使用命令iptables-save来保存规则。一般用

iptables-save > /etc/sysconfig/iptables

生成保存规则的文件 /etc/sysconfig/iptables，

也可以用

service iptables save

它能把规则自动保存在/etc/sysconfig/iptables中。

当计算机启动时，rc.d下的脚本将用命令iptables-restore调用这个文件，从而就自动恢复了规则。

### iptables 命令总结

当您运行 `iptables -nvL` 命令时，输出中的列包括：

1. **pkts (packets):** 显示匹配特定规则的数据包数量。这是一个计数器，指示有多少个数据包与规则匹配。

2. **bytes:** 显示匹配特定规则的总字节数。这是一个计数器，表示规则匹配的所有数据包的字节数总和。

3. **target:** 显示规则匹配时采取的动作。它可以是 ACCEPT、DROP、REJECT、等等。当数据包匹配了某一规则时，将执行目标指定的操作。

4. **prot (protocol):** 显示规则所适用的协议。例如，它可以是 TCP、UDP、ICMP 等。

5. **opt (options):** 显示与规则相关的选项。这可能包括一些特定的条件或标志。

6. **in (input interface):** 显示数据包进入系统的网络接口。这是输入接口。

7. **out (output interface):** 显示数据包离开系统的网络接口。这是输出接口。

8. **source:** 显示数据包的来源地址或地址范围。

9. **destination:** 显示数据包的目标地址或地址范围。

#### 查看

1. 详细查看

   ```sh
   $ iptables -nvL
   ```

2. 查看

   ```sh
   $ iptables -nL
   ```

3. 指定链查看

   ```sh
   $ iptables -nL PREROUTING
   ```

4. 指定表查看

   ```sh
   $ iptables -t filter -nL
   ```

5. 显示规则编号

   ```sh
   $ iptables -nL --line-numbers
   ```

#### 增加

#### 删除

1. 根据序号删除

   ```sh
   $ iptables -t nat -nvL --line-numbers
   ```

1. 删除具体的规则

   ```sh
   iptables -t nat -D POSTROUTING -s <gatewayIp> ! -o <bridgeName> -j MASQUERADE
   ```

   

### Linux Veth

一对虚拟网卡

https://www.cnblogs.com/Skybiubiu/p/17315134.html

- veth pair（Virtual Ethernet Pair）是一种 Linux 内核技术，可用于将两个虚拟网络接口连接在一起，从而可以在两个不同的命名空间之间进行通信。它常常被用于容器的实现，比如 Docker 中的容器网络，以提供网络隔离和互联。
- veth pair 包括两个虚拟网络接口，这两个网络接口是成对出现的，一个在一个命名空间中，另一个在另一个命名空间中。其中一个接口的主机和路由信息将用于在这个命名空间和其它网络之间进行通信，而另一个接口则被限制在本地网络命名空间中。

例如，当创建一个 Docker 容器时，内部将会创建一个独立的网络命名空间。此时，将会创建两个 veth pair 接口，一个接口将附加到容器内的网络命名空间中，另一个接口将附加到主机的网络命名空间中。这些 veth pair 接口之间的通信将被用来进行容器中的应用程序访问主机网络的操作，以及主机网络中的应用程序访问容器中的应用程序的操作。

veth pair 常被用于创建网络隔离，实现多个应用程序之间的网络隔离。它提供了一种简单而密集的方式来实现不同网络命名空间之间的通信，同时保持了适当的隔离性，最终实现了更好的网络性能和更好的安全性。
总体而言，veth pair 是 Linux 内核技术的一个基本组成部分，它广泛用于容器化环境中以提供网络隔离和互联。

#### veth pair 的操作示例

1. 创建新的veth pair

   ```sh
   $ ip link add veth0 type veth peer name veth1
   ```

   > 使用`ip link add`工具创建了一个虚拟以太网对，其中veth0是一个端点，veth1是另一个端点
   >
   > - `ip link add`: 这是Linux系统中用于管理网络接口的命令。`ip link`用于配置网络接口。
   > - `veth0`: 这是第一个虚拟以太网接口的名称。你可以根据需要选择不同的名称，这只是一个标识符。
   > - `type veth`: 这个部分指定了创建的接口类型。在这种情况下，它是一个虚拟以太网接口（veth）。
   > - `peer name veth1`: 这部分定义了虚拟以太网对的对端。`veth1`是第二个虚拟接口的名称，与第一个接口(`veth0`)相对应。在虚拟以太网对中，一个端点发送的数据会被另一个端点接收，从而实现两个端点之间的通信。

2. 将veth1分配到新的网络命名空间

   ```sh
   $ ip netns add test-ns
   $ ip link set veth1 netns test-ns
   ```

   > - `ip netns add`: 创建一个新网络命名空间
   > - `ip link set`: 这是 `ip` 命令中用于配置网络接口的部分。在这个命令中，`link` 表示对网络链路（接口）进行操作。
   > - `veth1`: 这是要操作的网络接口的名称，即要移动的虚拟以太网接口的名字。
   > - `netns test-ns`: 这个部分指定了目标网络命名空间，即 `test-ns`。`netns` 表示将接口移到指定的网络命名空间。这将导致 `veth1` 从主机的默认网络命名空间中移动到 `test-ns` 这个网络命名空间中。

3. 在新的命名空间中，使用以下命令配置 veth1 接口IP地址，并启用

   ```sh
   $ ip netns exec test-ns ifconfig veth1 192.168.1.2/24 up
   ```

   > - `ip netns exec test-ns`: 这个部分使用 `ip netns exec` 命令，它允许在指定的网络命名空间中执行其他命令。在这里，`test-ns` 是目标网络命名空间，而后面的命令 `ifconfig veth1 192.168.1.2/24 up` 将在该命名空间中执行。
   > - `ifconfig veth1 192.168.1.2/24 up`: 这个部分是在指定网络命名空间中执行的命令。具体解释如下：
   >   - `ifconfig`: 这是配置网络接口的命令。
   >   - `veth1`: 这是要配置的网络接口的名称。
   >   - `192.168.1.2/24`: 这是分配给 `veth1` 接口的IP地址和子网掩码。在这里，IP地址是 `192.168.1.2`，子网掩码是 `/24`，表示一个24位的子网，即255.255.255.0。
   >   - `up`: 这个参数用于启用 `veth1` 接口，使其处于启动状态，能够传输数据。

   ```sh
   # 或者使用ip工具也是可以的
   $ ip netns exec test-ns ip addr add 192.168.1.2/24 dev veth1
   ```

   > - `ip`: 这是 Linux 中用于配置网络接口和路由表等网络相关信息的命令。
   > - `addr add`: 这是 `ip` 命令的一部分，表示添加一个IP地址到指定的网络接口。
   > - `192.168.3.101/24`: 这是要添加到网络接口的IP地址。`192.168.3.101` 是IP地址，而 `/24` 表示子网掩码，这里是一个24位的子网，即255.255.255.0。
   > - `dev veth1`: 这指定了要将IP地址添加到哪个网络接口上，即 `veth1`。

4. 在主机的命名空间中，使用以下命令配置 veth0 接口IP地址，并启用

   ```sh
   $ ifconfig veth0 192.168.1.1/24 up
   # 或者
   $ ip addr add 192.168.1.1/24 dev veth0
   ```

5. 最后，我们可以尝试在两个不同的命名空间中相互连通。在 test-ns 命名空间中打开一个终端窗口，在该窗口中使用以下命令与主机的命名空间中的 veth0 接口进行通信：

   ```sh
   ip netns exec test-ns ping 192.168.1.1
   ```

### Linux Bridge

https://cloud.tencent.com/developer/article/1871867

对于普通的网络设备，就像一个管道，只有两端，数据从一端进，从另一端出。而 Bridge 有多个端口，数据可以从多个端口进，从多个端口出。如物理网卡从外面网络中收到的数据会转发给内核协议栈，而从协议栈过来的数据会转发到外面的物理网络中。

- Linux Bridge（Linux桥接）是一种在Linux系统上实现的虚拟交换机。Linux桥接工作在数据链路层（第二层），类似于物理交换机，但它是在软件层面实现的。通过桥接，可以将多个网络设备连接成一个单一的网络，而不同的设备可以像连接到同一个交换机上一样进行通信。这对于虚拟化、容器化和网络隔离等场景非常有用。
- Linux桥接虽然在数据链路层（第二层）工作，但也可以配置IP地址。这是因为Linux桥接设备本身在网络堆栈中被视为一个网络接口，可以与其他网络接口一样具有IP地址。
- Linux Bridge 是虚拟交换机，也是网络设备，也可以配置ip地址
- bridge有多个端口，数据可以从任何端口进来，进来之后从哪个口出去和物理交换机的原理差不多，要看mac地址。

**虚拟网桥是什么？**

我的理解是就是一个虚拟的二层交换机



### 构建docker网络模型

https://www.lixueduan.com/posts/docker/10-bridge-network/

实现的效果主要如下图：

<img src="https://typora-img-xue.oss-cn-beijing.aliyuncs.com/img/docker-bridge-network.png" alt="https://img.lixueduan.com/docker/network/docker-bridge-network.png" style="zoom:67%;" />

#### 1 创建网络命名空间

使用网络命名空间来模拟容器

```sh
$ ip netns add ns1
$ ip netns add ns2
$ ip netns show
ns2
ns1
```

#### 2 创建veth pair

创建veth pair

```sh
$ ip link add veth0 type veth peer name veth1
$ ip link add veth2 type veth peer name veth3
$ ip link show type veth
6: veth1@veth0: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 02:7e:e6:7a:7f:4d brd ff:ff:ff:ff:ff:ff
7: veth0@veth1: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 26:0f:04:7e:b4:50 brd ff:ff:ff:ff:ff:ff
8: veth3@veth2: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether c6:d3:e0:a8:b7:89 brd ff:ff:ff:ff:ff:ff
9: veth2@veth3: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 46:27:d1:38:7e:70 brd ff:ff:ff:ff:ff:ff
```

#### 3 将veth一端放入“容器”

将veth一端放入到netns中

```sh
$ ip link set veth0 netns ns1
$ ip link set veth2 netns ns2
$ ip netns exec ns1 ip link show type veth
7: veth0@if6: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 26:0f:04:7e:b4:50 brd ff:ff:ff:ff:ff:ff link-netnsid 0
$ ip netns exec ns2 ip link show type veth
9: veth2@if8: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 46:27:d1:38:7e:70 brd ff:ff:ff:ff:ff:ff link-netnsid 0
$ ip link show type veth
6: veth1@if7: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 02:7e:e6:7a:7f:4d brd ff:ff:ff:ff:ff:ff link-netns ns1
8: veth3@if9: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether c6:d3:e0:a8:b7:89 brd ff:ff:ff:ff:ff:ff link-netns ns2
```

#### 4 创建bridge网桥

创建网桥

第一种方式

```sh
# 创建网桥
$ ip link add br0 type bridge
# 查看网桥
$ ip link show type bridge
...
11: br0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 2e:01:88:46:a3:83 brd ff:ff:ff:ff:ff:ff
```

第二种方式

```sh
# 需要先安装一个工具，安装过docker的机器一般会有
$ apt install bridge-utils
# 创建网桥
$ brctl addbr br0
```

#### 5 将veth另一端接入网桥

接入网桥

第一种方式

```sh
# 接入网桥
$ ip link set veth1 master br0
$ ip link set veth3 master br0

# 查看网桥连接状态
$ brctl show br0
bridge name     bridge id               STP enabled     interfaces
br0             8000.2e018846a383       no              veth1
                                                        veth3
# 增加路由规则
# $ ip netns exec ns1 ip route add default dev veth0
# $ ip netns exec ns1 ip route add default dev veth2
```

第二种方式

```sh
# 接入网桥
$ brctl addif br0 veth1
$ brctl addif br0 veth3
# 查看网桥连接状态
$ brctl show br0
bridge name     bridge id               STP enabled     interfaces
br0             8000.2e018846a383       no              veth1
                                                        veth3
```

#### 6 分配IP并启动

分配ip启动

```sh
# 分配br0的ip
$ ip addr add 172.100.0.1/24 dev br0
# 分配ns1中的veth0 ip
$ ip netns exec ns1 ip addr add 172.100.0.2/24 dev veth0
# 分配ns2中的veth2 ip
$ ip netns exec ns2 ip addr add 172.100.0.3/24 dev veth2
# 启动所有的网络设备
$ ip link set br0 up
$ ip netns exec ns1 ip link set veth0 up
$ ip netns exec ns2 ip link set veth2 up
$ ip link set veth1 up
$ ip link set veth3 up
```

#### 测试容器互通

测试从ns1上`ping`ns2

```sh
# 在一个终端上，使用tcpdump在br0上抓包
$ tcpdump -i br0 -n
```

```sh
# 在另一个终端，在ns1上 ping ns2
$ ip netns exec ns1 ping 172.100.0.3
```

https://segmentfault.com/q/1010000010011053?utm_source=sf-similar-question

添加一条iptables规则：`iptables -A FORWARD -i br0 -j ACCEPT`

测试成功

#### 测试宿主机访问“容器”

宿主机访问容器

```sh
# 在ns1上监听80端口
$ ip netns exec ns1 nc -lp 80
```

```sh
# 在宿主机上执行telnet
$ telnet 172.100.0.2 80
Trying 172.100.0.2...
Connected to 172.100.0.2.
Escape character is '^]'.

```

测试成功

#### 主机访问容器不通的原因之一

看看是不是主机设置了网络代理，unset一下就好

#### 7 配置容器内路由

让非`172.100.0.0/24`网段的数据包都发送给bridge，把bridge实际上成为了网关

```sh
# 设置规则
$ ip netns exec ns1 ip route add default via 172.100.0.1 dev veth0
$ ip netns exec ns2 ip route add default via 172.100.0.1 dev veth2
# 查看规则
$ ip netns exec ns1 ip route
default via 172.100.0.1 dev veth0 
172.100.0.0/24 dev veth0 proto kernel scope link src 172.100.0.2
$ ip netns exec ns2 ip route
default via 172.100.0.1 dev veth2 
172.100.0.0/24 dev veth2 proto kernel scope link src 172.100.0.3
# 可以看到访问其他网段下一跳为172.100.0.1
$ ip netns exec ns1 ip route get 10.10.10.10
10.10.10.10 via 172.100.0.1 dev veth0 src 172.100.0.2 uid 0 
    cache 
$ ip netns exec ns2 ip route get 10.10.10.10
10.10.10.10 via 172.100.0.1 dev veth2 src 172.100.0.3 uid 0 
    cache 
```

#### 8 宿主机开启转发功能

这一步不设置，容器就不能正常对外通信

方法一：

> 注意此方式不能持久话配置

```sh
$ sysctl net.ipv4.conf.all.forwarding=1
# 查看所有配置
$ sysctl --system
# 查看一个配置
$ sysctl -n net.ipv4.conf.all.forwarding
```

方法二：

第一种方式不能持久化配置，若要重启主机后依然生效，请使用这种方式

```sh
$ vim /etc/sysctl.conf # 找到#net.ipv4.ip_forward=1将注释去掉就行了
$ sysctl -p # 应用
```

#### 9 允许br0转发

```sh
# 查看默认策略及规则（ 默认策略可能是DROP，也可能是ACCEPT）
$ iptables -t filter -nvL FORWARD
# 若默认策略是DROP则需要配置允许br0转发(在测试容器互通已经展示过了)
$ iptables -t filter -A FORWARD -i br0 -j ACCEPT
```

#### 10 配置SNAT规则

**`MASQUERADE`**：MASQUERADE是NAT的一种形式，它将内部网络的私有IP地址映射为主机的公共IP地址，以便这些数据包能够正常访问外部网络。它会动态选择宿主机的一个IP做源地址转换，而`SNAT`动作必须在命令中指定固定的IP地址。

```sh
# 当源地址是172.100.0.0/24，出口设备不是br0，就执行源地址转换
$ iptables -t nat -A POSTROUTING -s 172.100.0.0/24 ! -o br0 -j MASQUERADE
```

- **`-s 172.100.0.0/24`:** 源IP地址，表示匹配源地址为172.18.0.0/24的数据包。
- **`! -o br0`:** 这个部分是一个条件，表示“不匹配输出接口为br0的数据包”。

#### 11 配置DNAT规则

```sh
# 将主机接收到的数据包目的地址改为“容器”地址。假设容器开放8080端口映射到主机8080端口
$ iptables -t nat -A PREROUTING ! -i br0 -p tcp -m tcp --dport 8080 -j DNAT --to-destination 172.100.0.2:8080
$ iptables -t nat -A OUTPUT -p tcp -m tcp --dport 8080 -j DNAT --to-destination 172.100.0.2:8080
```

- **`! -i br0`:** 这个条件表示"不匹配输入接口为br0的数据包"。也就是说，该规则将只匹配不经过br0接口的数据包。
- **`-p tcp -m tcp --dport 80`:** 这个条件表示匹配TCP协议且目标端口是80的数据包。
- `-m` 参数用于指定匹配模块（可以省略）

远程主机流量会经过PREROUTING DNET到172.100.0.2:8080。本机流量不会经过PREROUTING，直接经过OUTPUT DNET到172.100.0.2:8080

#### 测试端口映射

```sh
# 一个终端上
$ ip netns exec ns1 nc -lp 8080
```

```sh
# 另一个终端上 发现成功通信，是匹配到了OUTPUT那条命令
$ telnet 172.28.106.22 8080
Trying 172.28.106.22...
Connected to 172.28.106.22.
Escape character is '^]'.

```

#### 环境恢复

```sh
$ ip link set br0 down
$ brctl delbr br0
$ ip link  del veth1
$ ip link  del veth3
# 删除iptables规则
$ iptables -t nat -D {编号}
# 删除网络命名空间
$ ip netns delete ns1
$ ip netns delete ns2
```



#### MASQUERADE

关于masquerade的疑问？chatGPT的回答

**iptables -t nat -A POSTROUTING -s 172.100.0.0/24 ! -o br0 -j MASQUERADE 为什么我使用了这条命令后，我的网络命名空间就能和外网通信？**

这条iptables命令的作用是在NAT表的POSTROUTING链上添加一条规则，对源地址为172.100.0.0/24的数据包执行MASQUERADE动作。这将导致出站流量的源地址被替换为主机的公共IP地址，以便能够在互联网上正确路由。

当你的网络命名空间（Namespace）与主机共享网络命名空间，这条规则的效果就会影响到该网络命名空间内的流量。因此，如果你在网络命名空间内运行的容器使用了172.100.0.0/24子网，那么出站流量的源地址将被替换为主机的公共IP地址，使其能够在外部网络通信。

在网络命名空间内，这种配置类似于共享主机的网络栈，因此网络命名空间内的流量会经过主机的网络设备，并受到主机上iptables规则的影响。

这样的配置允许网络命名空间内的容器能够与外部网络通信，同时通过MASQUERADE确保了流出网络命名空间的流量被正确NAT转换。

**比如我主机的ip是172.28.106.2，那么远程主机返回的目的IP不就是172.28.106.2，我的网络命名空间又是怎么接收到这个流量**

在这种情况下，当你的网络命名空间的容器通过MASQUERADE之后，远程主机发送回的数据包的目的IP确实是你主机的公共IP地址，即172.28.106.2。这是因为MASQUERADE将出站流量的源地址替换为主机的公共IP地址，以便能够正确路由。

网络命名空间的容器能够接收到这个流量，是因为Linux内核中的NAT表（Network Address Translation）会在返回的数据包上执行逆向的NAT操作，将目的地址还原回容器的原始地址。这个过程是由NAT表维护的映射关系实现的，它负责记录源地址和目的地址之间的映射关系，以确保回程流量能够被正确转发给相应的容器。

因此，虽然返回的数据包的目的IP是主机的公共IP地址，但由于NAT表的作用，内核会将其还原为容器的原始IP地址，并将数据包正确传递到相应的网络命名空间中的容器。

**你说的Linux内核中的NAT表是iptables中的nat表吗**

是的，我在之前的回答中提到的"Linux内核中的NAT表"指的就是iptables中的`nat`表。具体来说，iptables中的`nat`表主要包含两个链，分别是`POSTROUTING`链和`PREROUTING`链，用于处理网络地址转换（NAT）。

- `POSTROUTING`链：用于对出站数据包进行处理，通常用于源地址转换（SNAT）或MASQUERADE。
  
- `PREROUTING`链：用于对进站数据包进行处理，通常用于目标地址转换（DNAT）。

在你的情况中，通过在`POSTROUTING`链上使用MASQUERADE规则，你正在执行源地址转换，将网络命名空间内容器的出站流量的源地址替换为主机的公共IP地址。这使得容器能够与外部网络通信。当远程主机回复时，`nat`表会根据NAT映射关系将目的地址还原为原始的容器IP地址，以确保回程流量能够正确传递到容器。



### net库

go原生库

### github.com/vishvananda/netlink库

操作网络接口、路由表等配置的库，使用它的调用相当于我们直接通过IP命令去管理网络接口

### github.com/vishvananda/netns库

是进出net namespace的库

### 实现docker网络模型

![img](https://staticcdn1-5.umiwi.com/epms_ebook/e311279b111d834234a905b481f6d724.jpg?x-oss-process=image/resize,w_1440,m_lfit)





```sh
$ ./mydocker network create --driver bridge --subnet 192.168.101.0/24 --gateway 192.168.101.1 testbridge 
$ ./mydocker network list
$ ./mydocker network remove testbridge
$ ./mydocker run -it -p 8080:8080 -p 8081:8081 -net testbridge busybox sh
# 进入容器后
$ ip addr show
$ ip route show
$ ping 一个外网 # 成功ping通
$ ./mydocker run -it -p 8080:8080 -p 8081:8081 -net testbridge busybox sh # 另一个终端启动
$ ip addr show
$ ip route show
$ ping 第一个容器 # 成功ping通

```

```sh
$ ip link show type veth
$ ip link show type bridge
$ ip link show testbridge
$ ip link delete testbridge
$ ip addr show testbridge
$ iptables -t nat -nvL POSTROUTING --line-numbers
$ iptables -t nat -nvL PREROUTING --line-numbers
$ iptables -t nat -D POSTROUTING ?
$ iptables -t nat -D PREROUTING ?
$ cat /var/run/mydocker/network/network/testbridge.json
$ rm -f /var/run/mydocker/network/network/testbridge.json
$ ls /var/run/mydocker/container
$ rm -rf /var/run/mydocker/container
$ ls /sys/fs/cgroup/system.slice/
$ rmdir /sys/fs/cgroup/system.slice/mydocker*
$ ls /var/lib/mydocker/overlay
$ rm -rf /var/lib/mydocker/overlay/...
$ umount /var/lib/mydocker/overlay/*/mnt
```



## 高级实践

### 创建一个可访问的nginx容器

完成对外可访问的容器 注意mydocker是我们build，docker是官方docker

#### 创建mydocker的nginx镜像

nginx镜像创建最快的方式是docker export官方nginx的镜像

```sh
$ docker run -d nginx
$ docker ps
$ docker exec -it 84e655ef17e0 /bin/bash
$ echo "daemon off;" >> /etc/nginx/nginx.conf # 让nginx在容器中前台启动
$ cat /etc/nginx/nginx.conf
$ exit
$ docker export [容器id] -o mynginx.tar
$ mkdir -p /var/lib/mydocker/overlay/image/
$ mv mynginx.tar /var/lib/mydocker/overlay/image/ # 移动到mydocker存储镜像文件的地方
$ ls /var/lib/mydocker/overlay/image/
mynginx.tar
```

#### 创建nginx容器

```sh
$ ./mydocker images
$ sysctl -w net.ipv4.ip_forward=1 # 全局允许forwark转发
$ ./mydocker network create --driver bridge --subnet 192.168.99.0/24 --gateway 192.168.99.1 mynginxbridge # 创建mydocker桥接网络 
$ ./mydocker network list
$ ./mydocker run -d --name bird -net mynginxbridge -p 8888:80 mynginx nginx # 启动nginx镜像
$ ./mydocker ps
$ ps -ef | grep [容器在主机上的pid]
$ ping 192.168.99.2 # 容器ip
$ curl 192.168.99.2:80 # 主机访问容器ip:port
$ curl 10.211.55.9:8888 # 主机ip访问
$ curl 10.211.55.2:8888 # 内网中另外一台机器访问
# 浏览器打开，如下图
```

![image-20240315170822159](https://typora-img-xue.oss-cn-beijing.aliyuncs.com/img/image-20240315170822159.png)

#### 环境还原

```sh
$ ./mydocker stop bird
$ ./mydocker rm bird
$ ./mydocker network remove mynginxbridge
$ sysctl -w "net.ipv4.ip_forward=0"
$ rm -rf /var/lib/mydocker
$ rm -rf /var/run/mydocker
```

### 创建一个flask+redis的计数器

完成能够互相访问的容器

#### 创建mydocker的myredis镜像

```sh
$ docker run -d redis:6.2.14 # 请使用特定的版本，redis:7可能会有问题
$ docker ps
$ docker export d05fb45af85c -o myredis.tar
$ mkdir -p /var/lib/mydocker/overlay/image/
$ mv myredis.tar /var/lib/mydocker/overlay/image
$ ./mydocker images
```

#### 创建redis容器

```sh
$ ./mydocker network create --driver bridge --subnet 192.168.99.0/24 --gateway 192.168.99.1 myflask
$ ./mydocker network list
$ ./mydocker run -d --name redis -net myflask myredis /usr/local/bin/redis-server
$ ./mydocker ps
$ ps -ef | grep [redis容器pid]
$ ./mydocker exec redis sh
```

#### 创建mydocker的myflask镜像

```sh
$ docker run -d python:2.7 top -b
$ docker export daf6f48c7aa3 -o python.tar
$ cat /etc/issue
$ apt update && apt install vim -y
$ mkdir ~/.pip
$ cd ~/.pip/
$ touch pip.conf
$ vim pip.conf
$ pip install flask
$ pip install redis
$ vim app.py
$ docker export daf6f48c7aa3 -o myflask.tar
$ mv myflask.tar /var/lib/mydocker/overlay/image
```

```sh
echo "deb https://mirrors.aliyun.com/debian/ buster main non-free contrib" >> etc/apt/sources.list
echo "deb-src https://mirrors.aliyun.com/debian/ buster main non-free contrib" >> etc/apt/sources.list
echo "deb https://mirrors.aliyun.com/debian-security buster/updates main" >> etc/apt/sources.list
echo "deb-src https://mirrors.aliyun.com/debian-security buster/updates main" >> etc/apt/sources.list
echo "deb https://mirrors.aliyun.com/debian/ buster-updates main non-free contrib" >> etc/apt/sources.list
echo "deb-src https://mirrors.aliyun.com/debian/ buster-updates main non-free contrib" >> etc/apt/sources.list
echo "deb https://mirrors.aliyun.com/debian/ buster-backports main non-free contrib" >> etc/apt/sources.list
echo "deb-src https://mirrors.aliyun.com/debian/ buster-backports main non-free contrib" >> etc/apt/sources.list
```

```sh
[global]
index-url = http://mirrors.aliyun.com/pypi/simple/
[install]
trusted-host=mirrors.aliyun.com
```

```python
import os
from flask import Flask
from redis import Redis        
os.system('mknod -m 644 /dev/urandom c 1 9')
app = Flask(__name__)
redis = Redis(host='192.168.99.2', port=6379)
@app.route('/')
def hello():
  redis.incr('hits')
  return 'Hello World! I have been seen %s times.' % redis.get('hits')
if __name__ == "__main__":
  app.run(host="0.0.0.0", debug=True)
```

#### 创建myflask容器

```sh
$ ./mydocker run -d --name flask -net myflask -p 5000:5000 myflask python /root/app.py
$ ./mydocker ps
$ ps -ef | grep [flask容器的pid]
```

![image-20240314014707495](https://typora-img-xue.oss-cn-beijing.aliyuncs.com/img/image-20240314014707495.png)

![image-20240314014723708](https://typora-img-xue.oss-cn-beijing.aliyuncs.com/img/image-20240314014723708.png)

![image-20240314014806575](https://typora-img-xue.oss-cn-beijing.aliyuncs.com/img/image-20240314014806575.png)





































